%************************************************
\chapter{Aplicaciones de ZKP}\label{ch:aplicaciones} 
%************************************************


% TODO poner cómo hacerlo de firma, o no interactivo, con un hash


?
Fiat-Shamir para QR, Schnorr para logaritmo discreto, ...
Aplicación de ZKP en los certificados de Idemix. Analizar cómo realizan pruebas de AND, OR, etc.




%TODO: mencionar, para que quede claro en las no interactivas, que los retos pueden no se 0,1


% Hacerlas no interactivas


\section{Firma digital basada en pruebas de conocimiento cero}

Hemos visto que la interacción habitual en una prueba de conocimiento cero es enviar un \textit{testigo}, un \textit{reto} y una \textit{respuesta} en cada iteración.

\begin{center}
	\begin{tabular}{ll}
		P y V & conocen información previa $\Upsilon$
		\\
		P $\rightarrow$ V :& \textit{testigo} $u$
		\\
		V $\rightarrow$ P :& \textit{reto} $b$
		\\
		P $\rightarrow$ V :& \textit{respuesta} $w = \xi(u,b,\Upsilon)$
		\\
		V verifica & $\vartheta(u,b,w,\Upsilon)$.
	\end{tabular}
\end{center}

\hfil

La desventaja de estos protocolos es sincronizar a P y V para comunicarse, por la necesidad de que el verificador debe generar el reto para estar seguro de la prueba (por la propiedad de conocimiento cero).

Una técnica para convertir las pruebas en no interactivas es la \textit{heurística de Fiat-Shamir}, que consiste en sustituir el reto por un resumen digital $h$, \textit{hash} en inglés, del testigo $u$, de modo que para un P computacionalmente limitado, V puede confiar en que P no ha elegido $u$ tal que con el reto calculado pueda falsear la prueba.

Aprovechando la función del \textit{hash}, se puede convertir el protocolo en un esquema de firma digital de un mensaje $m$, realizando el \textit{hash} sobre el testigo y el mensaje a la vez (concatenándolos, por ejemplo).


\begin{center}
	\begin{tabular}{ll}
		P calcula :& \textit{testigo} $u$, \textit{respuesta} $w = \xi(u, $\textbf{h(u|m)}$,\Upsilon)$
		\\
		P $\rightarrow$ V :& \textit{\textbf{firma del mensaje}} $m$: \quad $(u,w)$
		\\
		V verifica & $\vartheta(u,h(u|m),w,\Upsilon)$.
	\end{tabular}
\end{center}

Podemos construir así una firma digital, con un solo mensaje, por lo que es válido para cualquier V, y donde P no ha debido compartir ninguna clave o información extra aparte de los parámetros del sistema, $\Upsilon$.

\hfil


\begin{remark}
	\hfil
	
	En las pruebas de conocimiento cero perfectas estudiadas, los retos consistían en un bit, por lo que los posibles valores son $0$ ó $1$ y un ataque a la función de \textit{hash} es muy fácil. Por ello, se utilizan versiones de ZKP donde el conjunto de los posibles valores del reto es suficientemente grande, por ejemplo, un entero representado en tantos bits como produce la firma digital, usualmente 256 o 512 bits.
	
	Al hacer este cambio, muchas veces perdemos la condición de perfecta en la prueba de conocimiento cero, rebajándola a otro de los tipos vistos, pero que en la práctica es perfectamente aceptable.
	
\end{remark}








\section{Protocolos de identificación basados en ZKP}
% Fiat-Shamir, FFS, GQ, Schnorr


Las pruebas de conocimiento cero tienen una gran aplicación en el campo de la seguridad informática, en particular en la \textbf{autenticación}. Tras la autenticación se aplicará autorización y control de acceso, por eso es importante un sistema de identificación fiable. Además, de entre las ventajas de las pruebas de conocimiento cero, un sistema de identificación basado en ZKP hereda privacidad, al no revelar información del usuario, y seguridad al no \textit{degradarse} con el uso, es decir, resiste al criptoanálisis por muchos mensajes que se intercepten, y ataques con mensajes elegidos. 

%TODO
TODO: poner mejor las ventajas.

Estos protocolos de identificación se basan en una prueba de conocimiento cero de un problema $Q$, donde P (el usuario) tiene un \textit{secreto} que le permite demostrar una instancia $Verdadera$ de $Q$ al verificador V, y que además conocer dicho secreto le relaciona con una identidad, con la ventaja de no tener que revelar el secreto.


\subsection{Protocolo de identificación de Fiat-Shamir}

El protocolo  de identificación más característico basado en ZKP y el problema QR es el de Fiat-Shamir.

Como hemos visto, el problema QR es \textbf{NP}, de modo que obtener una raíz cuadrada módulo un $N$ compuesto, es computacionalmente inviable, equivalente a factorizar $N$. Bajo esta suposición, podemos utilizar como información pública un residuo cuadrático módulo $N$, que llamaremos $v$, y asociarlo a una identidad, de modo que el usuario que conozca una de sus raíces cuadradas, el secreto $s$, podrá demostrar que $v$ es un residuo cuadrático por medio de una prueba de conocimiento cero.


\rule{\textwidth}{1pt}
\begin{algorithm}[Protocolo de identificación Fiat-Shamir]
	\hfil
	
	\textit{Configuración de la identidad}:
	\begin{enumerate}
		\item La entidad de confianza selecciona y publica $N=pq$, con $p$ y $q$ primos y secretos.
		
		\item Cada usuario P genera un secreto $s \in \mathbb{Z_N^*}$, coprimo con $N$ (si no, se podría obtener la factorización de $N$ y perder la seguridad del protocolo). Calcula $v \equiv s^2 \, mod \, N$ y lo envía a la entidad de confianza como su clave pública.
		
	\end{enumerate}
	
	
	\textit{Protocolo}: Repetir $t$ rondas:
	\begin{enumerate}
		\item P escoge aleatoriamente $r \in_R \mathbb{Z_N^*}$, el \textit{compromiso}.
		\item $P \rightarrow V$:\quad $u \equiv r^2 \, mod \, N$, el \textit{testigo}.
		\item $V \rightarrow P$:\quad $b \in_R \{0,1\}$, el \textit{reto}.
		\item $P \rightarrow V$:\quad $w \equiv r\cdot s^b \, mod \, N$, la \textit{respuesta}.
		\item V verifica si \quad $ w^2 \equiv u\cdot v^b \, mod \, N$.
	\end{enumerate}
	
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil


El protocolo de Fiat-Shamir es casi idéntico a la prueba interactiva \ref{QRinteractive:alg}, donde aquí $(v,N)$ hace el papel de instancia $Verdadera$ del problema QR, y como P, el usuario, es una máquina computacionalmente limitada, en vez de elegir aleatoriamente el residuo cuadrático $u$ y la raíz cuadrada $w$, parte de las raíces cuadradas, $s$ y $r$, para poder calcular $u$, $v$ y $w$ elevando al cuadrado. Como los valores que se envían siguen siendo $u$, un residuo cuadrático aleatorio, $b$ un bit de reto, y $w$ una raíz cuadrada aleatoria de $u$ o $uv$, según $b$, las transcripciones del protocolo de Fiat-Shamir son las mismas que las de la prueba interactiva, que sabemos que es de conocimiento cero perfecta.

\hfil

El intento de ataque que vimos en la demostración de robustez varía ligeramente para Fiat-Shamir, pues el objetivo es intentar demostrar que $v$ es residuo cuadrático, sin conocer $s$ u otra raíz cuadrada, necesaria para una máquina de cómputo limitado del mundo real.

Un atacante debe adivinar el bit del reto que recibirá, de modo que si cree que $b=0$ calcula el testigo como en el protocolo, pero si cree que $b=1$, calcula en el paso 2 el testigo $u \equiv r^2\cdot v^{-1} \, mod \, N$, y en 4 la respuesta $w \equiv r \, mod \, N$. En ambos casos fallaría si no adivina $b$ correctamente, pues para corregir su error debería ser capaz de calcular, respectivamente, una raíz cuadrada de $v$, que permitiría pasar la prueba siempre, o una raíz cuadrada de $u \equiv r^2\cdot v^{-1} \, mod \, N$, computacionalmente inviable pues $p$ y $q$ los guarda como secretos la entidad de verificación.

Como en la prueba interactiva, un atacante tiene una probabilidad de $1/2$ de engañar a V en cada ronda, de modo que la robustez se mantiene con una probabilidad de ataque de $2^{-t}$. Si P pasa correctamente las $t$ rondas, V da por válida la prueba. Si falla aunque sea sólo una, rechaza la identificación.

\hfil

Un detalle importante a tener en cuenta es que, considerando ordenadores reales para el caso práctico, si P no utiliza un buen generador de números aleatorios para sus $r$ del paso 1, un atacante podría adivinar cuándo repetirá el $r$, mandar $b=0$ y $b=1$, y así calcular el secreto $s$.




\subsection{Protocolo de identificación de Feige-Fiat-Shamir}

% TODO: no estoy convencido de poner este. En el Fiat-Shamir el protocolo es prácticamente la prueba de conocimiento cero formal, aquí se intuye que se basa en la dificultad de QR, pero ya está.

Una variación del protocolo de Fiat-Shamir para disminuir el número de mensajes intercambiados combinando varios testigos y retos a la vez.

\rule{\textwidth}{1pt}
\begin{algorithm}[Protocolo de identificación Feige-Fiat-Shamir]
	\hfil
	
	\textit{Configuración de la identidad}:
	\begin{enumerate}
		\item \textit{Parámetros del sistema}: La entidad de confianza publica el módulo $N=pq$, con $p$ y $q$ $\equiv \, mod \, 4$, primos guardados secretos, de modo que $-1$ es un no-residuo cuadrático con símbolo de Jacobi 1. También define los enteros $k$ y $t$ que definen la seguridad.
		
		\item \textit{Selección del secreto}: Cada usuario P hace:
		
		\subitem (a) Selecciona aleatoriamente un vector $(s_1,s_2,\dots ,s_k)$, donde cada  $s_i \in \mathbb{Z_N^*}$ y $mcd(s_i, N)=1$. Además, elige también aleatoriamente $k$ bits $(b_1, b_2, \dots , b_k)$.
		
		\subitem (b) Calcula $v_i \equiv (-1)^{b_i}\cdot (s_i^2)^{-1} \, mod \, N$ para cada $i=1,\dots k$.
		
		\subitem (c) El usuario se identifica ante la entidad de confianza y envía su \textit{clave pública} $(v_1,\dots , v_k; N)$, y guarda su \textit{clave privada} $(s_1, \dots , s_k)$.
		
	\end{enumerate}
	
	
	\textit{Protocolo}: Repetir $t$ rondas:
	\begin{enumerate}
		\item P escoge aleatoriamente $r \in_R \mathbb{Z_N^*}$ y un bit $b \in_R \{0,1\}$.
		\item $P \rightarrow V$:\quad $u \equiv (-1)^b \cdot r^2 \, mod \, N$, el \textit{testigo}.
		\item $V \rightarrow P$:\quad $(b_1,\dots ,b_k)$, con cada $b_i \in_R \{0,1\}$, el \textit{reto}.
		\item $P \rightarrow V$:\quad $w \equiv r\cdot \prod_{j=1}^{k} s_j^{b_j} \, mod \, N$, la \textit{respuesta}.
		\item V verifica si \quad $ u \equiv \pm \, y^2 \cdot \prod_{j=1}^{k} v_j^{b_i} \, mod \, N$.
	\end{enumerate}
	
\end{algorithm}
\rule{\textwidth}{1pt}

% indicar que la seguridad es la probabilidad 2^-kt de adivinar en cada ronda el vector del reto










%
%
%
%
%

% TODO:
% Si en los preliminares de QR ampliamos a la dificultad de solucionar una raíz n-ésima, podemos meter Guillou-Quisquater (GQ), y dejar caer que es ZKP al ser una extensión de Fiat-Shamir, o demostrar formalmente que es ZKP (~).


% Si metemos preliminares del logaritmo discreto y demostramos que es ZKP, ponemos Schnorr.


% https://crypto.stackexchange.com/questions/9997/perfect-zero-knowledge-for-the-schnorr-protocol

% Indican que demostrar que Schnorr es ZKP con un challenge grande no se puede, porque no se conoce un simulador eficiente
