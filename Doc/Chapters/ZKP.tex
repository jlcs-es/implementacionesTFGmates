%************************************************
\chapter{Pruebas de Conocimiento Cero}\label{ch:zkp} 
%************************************************

% REF
% Fundamentals pieprzyk2013fundamentals
% https://es.wikipedia.org/wiki/Prueba_de_conocimiento_cero 
% https://en.wikipedia.org/wiki/Interactive_proof_system
% How to Prove a Theorem So No One Else Can Claim It, Manuel Blum
% rosen2007discrete
% damgardcommitment
% blum

% Intro
% Ejemplo intuitivo del laberinto
% Pruebas interacticas: completitud y solvencia/solidez/robustez == completo y robusto/sólido, apartado corto, poner QR en el siguiente
% Prueba de conocimiento cero
%	Perfect vs Comp.
%	QR: es Perfect ZKP, y aplicaciones (id de Shamir, ...)
%	


% Para la estadística referenciar:
% JL Gomez Pardo Introduction to cryptography with Mapple pardo2012introduction
% Elementos probabilidad Zoroa
%
% Fundamentals
% https://en.wikipedia.org/wiki/Computational_indistinguishability

Las pruebas de conocimiento cero, con siglas ZKP del inglés \textit{Zero-Knowledge Proofs}, permiten demostrar la veracidad de una declaración, sin revelar nada más de ella. En las ZKP intervienen dos partes, el \textit{Prover} y el \textit{Verifier}, o Probador y Verificador. El Probador asegura que una declaración es cierta, y el Verificador quiere convencerse de ello a través de una interacción con el Probador, de modo que al final de la misma, o bien acaba convencido de que la declaración es cierta, o bien descubre, con una alta probabilidad, que el Probador mentía.

Las pruebas de conocimiento cero surgen a partir de los sistemas de pruebas interactivas, que forman una parte importante de la teoría de complejidad computacional, a las que añadiendo la propiedad de \textit{conocimiento cero} obtenemos el subconjunto de sistemas interactivos que conforman las pruebas de conocimiento cero.

Las referencias utilizadas para este capítulo se pueden encontrar en \citep{pieprzyk2013fundamentals, rosen2007discrete, blum, damgardcommitment, pardo2012introduction, menezes1996handbook, stinson2005cryptography}.


\section{Sistemas de Pruebas Interactivas}

Un \textit{sistema de prueba interactivo} es un concepto de la teoría computacional que modela el intercambio de un número finito de mensajes entre dos partes, el probador P y el verificador V, con el objetivo de que P demuestre a V que una instancia de un problema de decisión es $Verdadera$. V tiene una capacidad de cómputo limitada, a lo sumo un algoritmo probabilístico de tiempo de cómputo polinomial. P es computacionalmente todopoderoso. Al final del intercambio de mensajes, o bien V acepta que la instancia es $Verdadera$, o bien la rechaza por ser $Falsa$.

\begin{definition}

	
	Se dice que un problema de decisión $Q$, no necesariamente en \textbf{NP},  tiene un \textit{sistema de prueba interactivo} si tiene un protocolo de interacción polinomialmente acotado en número de mensajes que cumple:
	
	\begin{itemize}
		\item \textit{Completitud} Para toda instancia $q$ $Verdadera$, del problema $Q$, V acepta $q$ como $Verdadera$. 
		\item  \textit{Robustez} Para cada instancia $q$ $Falsa$, ningún P, incluso si no sigue el protocolo, puede convencer a V de que $q$ es $Verdadera$, excepto con una pequeña probabilidad.
		\item Alternativa:
		\item \textit{Robustez} Para cada instancia $q$ $Falsa$, V rechaza la prueba de $q$ con una probabilidad no menor que $\epsilon = 1-n^{-c}$, para cualquier constante $c>0$ y donde $n$ es el tamaño de la instancia.
	\end{itemize}

\end{definition}

En resumen, si la instancia del problema $Q$ que P quiere demostrar es $Verdadera$, el protocolo siempre funciona, no hay falsos negativos, pero si la instancia es $Falsa$, hay una pequeña probabilidad de que $V$ la acepte como $Verdadera$, pueden haber falsos positivos una probabilidad casi despreciable.

Un P o un V que no siguen el protocolo e intentan romper estas propiedades, los llamaremos un P o V \textit{tramposos}.


\begin{definition}
	Denominamos clase de problemas \textbf{IP} (Interactivos en tiempo Polinomial) al conjunto de problemas de decisión para los que existe un sistema de prueba interactivo.
\end{definition}

\begin{proposition}
	\textbf{NP} $\subset$ \textbf{IP}.
\end{proposition}

\begin{proof}
	Sea $Q$ un problema \textbf{NP}. Definimos el siguiente protocolo:

	\begin{enumerate}
		\item  P resuelve la instancia del problema gracias a su capacidad de cómputo ilimitada y genera el certificado para V, que existe para cualquier instancia $Verdadera$ por $Q\in$ \textbf{NP} (\ref{def:NP}).
		\item  V recibe y puede verificar el certificado en tiempo polinomial. Si es válido, V acepta como $Verdadera$ la instancia. Si no, rechaza la prueba.
	\end{enumerate}

	El protocolo es completo y robusto, con probabilidad nula de falso positivo, pues si la instancia es $Falsa$, ningún P, honesto o tramposo, puede generar un certificado que no existe.

\end{proof}


\hfil

\paragraph{Prueba Interactiva para el Problema QR}

\hfil

\hfil

Vamos a ver una prueba interactiva para demostrar que un entero $x$ con Símbolo de Jacobi 1 respecto a $n$, $x \in \mathbb{Z}^Q_n$, es un residuo cuadrático, $x \in \mathbb{Z}^{Q+}_n$.

\hfil

\begin{tabular}{|ll}
	\textit{Nombre:} & Problema QR. \\
	\textit{Parámetros:} &Un entero compuesto impar $N$, y el entero $x\in \mathbb{Z}^Q_N$. \\
	\textit{Pregunta:} & ¿Es $x$ un residuo cuadrático, $x \in \mathbb{Z}^{Q+}_N$? \\
\end{tabular}
\\

\hfil

Una instancia $Verdadera$ del problema es un $x$ residuo cuadrático módulo $N$. Una prueba interactiva para demostrar que $x$ es residuo cuadrático es la siguiente:

\hfil

\rule{\textwidth}{1pt}
\begin{algorithm}[Prueba interactiva para QR]
	
	\hfil
	
	\textit{Datos comunes}: Una instancia ($x$, $N$) del Problema QR. $n$ es el tamaño de la instancia.
	
	\textit{Protocolo}: Sea $t(n)$ un polinomio en $n$. P y V repiten $t(n)$ veces los siguientes pasos.
	
	\begin{enumerate}
		
		\item P $\rightarrow$ V :\quad $u \in_R \mathbb{Z}^{Q+}_N$ \quad (P elige aleatoriamente $u$ en $\mathbb{Z}^{Q+}_N$).
		
		\item V $\rightarrow$ P :\quad $b \in_R \{0,\,1\}$.
		
		\item P $\rightarrow$ V :\; $w$,\; una raíz cuadrada módulo $N$ aleatoria, de $x$ si $b=0$, o bien de $x\cdot u$ si $b=1$.
		
		\item V comprueba si:
		\[
			w^2 \overset{?}{\equiv}
			\begin{cases}
				u\, mod\, N, & si\ b = 0\\
				xu\, mod\, N, & si\ b = 1.\\
			\end{cases}
		\]
		
		Si la comparación falla, V termina en rechazo. En caso contrario, vuelve al paso 1.
		
		
	\end{enumerate}

	Tras $t(n)$ rondas, V termina y acepta la instancia como $Verdadera$, $x$ es un residuo cuadrático módulo $N$.
	
	\label{QRinteractive:alg}
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil


\begin{theorem}
	El problema QR tiene un sistema de prueba interactiva.
	\label{theo:QRint}
\end{theorem}

\begin{proof}
	
	El protocolo se ejecuta $t(n)$ veces, un número de iteraciones polinomialmente asociado al tamaño $n$ de la entrada, por lo que hay un número finito de mensajes que V, computacionalmente limitado, puede llevar a cabo. 
	
	\hfil 
	
	Queda ver que el protocolo anterior es completo y robusto.
	
	La prueba es \textit{completa}, pues para cualquier instancia $Verdadera$ de QR, $x \in \mathbb{Z}^{Q+}_N$, V acepta la prueba de P. En cada iteración, como P es computacionalmente todopoderoso, puede calcular $w$, una raíz cuadrada módulo $N$ de $x$ o $xu$, según el valor de $b$, ambos en $\mathbb{Z}^{Q+}_N$.
	
	Para una instancia $Falsa$, $x \in \mathbb{Z}^{Q-}_N$, cuando V envíe $b=1$, si P sigue el protocolo $u$ será un residuo cuadrático, pero $x\cdot u$ es un no-residuo cuadrático módulo $N$, por lo que no podrá calcular $w$ por mucho poder computacional ilimitado que tenga. Un P tramposo podría intentar engañar a V en el caso $b = 1$ eligiendo $u$ tal que $xu$ es un residuo cuadrático, pero entonces $u$ es un no-residuo cuadrático y fallaría la prueba si $b=0$.
	
	Una vez P se compromete con un $u$, residuo cuadrático o no, la probabilidad de que V lo rechace en esa iteración es $1/2$, según elija $b=0$ ó $1$. Como el protocolo se ejecuta $t(n)$ veces, la probabilidad de que un P tramposo pueda engañara V en todos es de $2^{-t(n)}$. Vemos entonces que el protocolo cumple la propiedad de \textit{robustez}.
\end{proof}


% TODO: para la presentación, si preguntan por qué t(n) depende del tamaño de la entrada, preparar ejemplo de Z_5 o Z_15 mejor, por 15=3*5 los primos impares, indicar que hay 7 residuos cuadráticos y 7 no-residuos, que la cantidad de u's distintos que puede tomar aleatoriamente de entre los rq y los no-rq para intentar engañarlo es mínima, y en pocas iteraciones pueden haber probado todas las combinaciones, y seguir el protocolo es repetir valores ya contrastados, y comparando con primos de 2048 bits, se pueden pedir más iteraciones.


\section{Pruebas de conocimiento cero}

% Introducción: De manera informal,....
% Definiciones: Prueba de conocimiento (como subconjunto de pruebas de problemas de decisión?), Ensemble, View, Simulator

%TODO: ahora que se habla más de un secreto, que es lo que queremos mantener privado en P, demostrar de la robustez, que si un cheating P no conoce el secreto, pero pasa la prueba, tiene un conocimiento equivalente al secreto. Dem por tema de la probabilidad.


Entre las pruebas interactivas existe un subconjunto que llamamos de \textit{conocimiento cero} si durante el protocolo no se puede inferir información de P, aparte de la veracidad de la instancia. En particular, aún tras realizar la prueba, y estar V convencido, éste no podría repetirla a otro verificador tomando el lugar de P.

\hfil

Antes de ver una definición más formal de una prueba de conocimiento cero, necesitamos algunas definiciones previas.



\begin{definition}
	Llamamos \textit{Vista} a una transcripción de los mensajes intercambiados entre P y V durante la ejecución de una prueba interactiva.
\end{definition}

% Notación de una Vista

Pensemos en un protocolo con 3 mensajes por iteración. En la $i$-ésima ronda, P envía a V el valor $A_i$ como \textit{compromiso}, V responde con el \textit{reto} aleatorio $B_i$, y P termina enviando la \textit{prueba} $C_i$. La tupla $(A_i,\,B_i,\,C_i)$ son variables aleatorias de los posibles valores que se pueden intercambiar en una iteración. La Vista de la prueba interactiva sería
\[(A_1,\,B_1,\,C_1,\,A_2,\,B_2,\,C_2,\dots ,\,A_{t(n)},\,B_{t(n)},\,C_{t(n)})\],
la secuencia de los $t(n)$ mensajes intercambiados entre P y V.

Una Vista sólo es de interés para una instancia $Verdadera$, donde P realmente conoce si es $Verdad$. Para una instancia cuya prueba falla, o bien es realmente una instancia $Falsa$ o P no puede probarla, por ser tramposo y no conocer una prueba o \textit{secreto} que le permita pasar la prueba exitosamente con mayor probabilidad que la de los falsos positivos.


\begin{definition}
	Llamamos ensamble probabilístico, o \textit{ensemble} en inglés, a una familia numerable de variables aleatorias: $\{X_i\}_{i\in I}$, con $I$ numerable.
\end{definition}

Podemos estudiar entonces una Vista como un ensamble probabilístico. Dos Vistas serán iguales cuando las distribuciones de sus variables aleatorias sean idénticas.


\hfil

Denotaremos con V$^*$ a un verificador tramposo. Éste podría no generar los retos $B_i$ anteriores de manera independiente, podría incluso utilizar información previa de otras Vistas para generar los $B_i$ en un intento de extraer información extra de P. A esta información previa la llamaremos $h$ (historial).

Para una instancia $q$ y un verificador cualquiera V$^*$, escribimos la Vista de una prueba como:

\begin{center}
	$Vista_{P,V^*}(q,h) = (q,\,h,\,A_1,\,B_1,\,C_1, \dots ,\,A_{t(n)},\,B_{t(n)},\,C_{t(n)})$.
\end{center}

El verificador tramposo V$^*$ generará los retos $B_i$ con una función probabilística de tiempo polinomial $F$ tal que
\marginpar{Para un verificador honesto $F$ sería un generador de números aleatorios que no utiliza ninguno de los parámetros de entrada.}

\begin{center}
	$B_i = F(q,\,h,\,A_1,\,B_1,\,C_1, \dots ,\,A_{i-1},\,B_{i-1},\,C_{i-1},\,A_i)$.
\end{center}



\begin{definition}
	Un Simulador $S_{V^*}(q,h)$ es un algoritmo probabilístico de tiempo polinomial, que utiliza toda la información que V$^*$ tiene disponible (el historial $h$ y la función $F$), para generar una transcripción de una prueba interactiva, para una instancia $q$ del problema $Q$, sin necesidad de interactuar con P.
\end{definition}

Un Simulador se puede ver como un generador de ensambles probabilísticos, las Vistas de una prueba.


\hfil

Podemos describir, por fin, la tercera propiedad, además de la \textit{completitud} y \textit{robustez}, que debe tener una prueba de conocimiento cero. Se dice también que son ZKP perfectas porque en la práctica se pueden considerar otras definiciones menos restrictivas, las ZKP estadísticas y computacionales.


%\subsection{Pruebas de conocimiento cero perfectas}

\begin{definition}[Propiedad de conocimiento cero]
	\hfil
	
	Un sistema de prueba interactiva (completo y robusto), para un problema de decisión $Q$, es \textit{perfecta de conocimiento cero} si el ensamble $Vista_{P,V}(q,h)$ es idéntico al ensamble generado por un Simulador $S_{V^*}(q,h)$, para cualquier instancia $Verdadera$ $q\in Q$ y cualquier historial $h$.
\end{definition}

%La existencia de un Simulador $S_{V^*}(q,h)$, cuyos ensambles son iguales que los de una Vista generada entre un P y V honestos, implica que de la Vista no se puede obtener ninguna información que V no tuviera ya antes, pues V podía obtener con el Simulador cuantas Vistas quisiera, con el conocimiento que ya tenía.


%%%%
A primera vista, puede parecernos que nada tiene que ver la existencia de tal Simulador con no poder obtener información de P más allá de si la instancia es $Verdadera$. Pero es precisamente el hecho de que cualquier máquina M, que \textbf{no} conoce la solución (ni un certificado para comprobarla (\ref{def:NP})) pueda generar transcripciones del protocolo \textit{idénticas} a las que podríamos interceptar a un P y V verídicos. Si M no conoce el secreto, de sus simulaciones nada podemos sacar, y por tanto, tampoco de la interacción entre P y V.

%%%%


\hfil

\subsection{Residuos cuadráticos}

Ahora podemos volver al problema QR, que ya vimos en el \autoref{theo:QRint} que su prueba interactiva cumplía \textit{completitud} y \textit{robustez}.

\begin{theorem}
	La prueba interactiva (\ref{QRinteractive:alg}) del problema QR es de conocimiento cero.
\end{theorem}

\begin{proof}
	Sea $(x,N)$ una instancia $Verdadera$ del problema QR, $\exists y\in \mathbb{Z}_N$ tal que $y^2\equiv x \, mod \, N$. En la $i$-ésima ronda tenemos las siguientes variables aleatorias:
	
	\begin{enumerate}
		\item $U_i$, un residuo cuadrático aleatorio enviado por P en el primer mensaje, $u \in_R \mathbb{Z}^{Q+}_N$.
		
		\item $B_i$, un bit aleatorio generado por V, $b \in_R \{0,\,1\}$.
		
		\item $W_i$, una \textit{prueba} de P, $w \in_R \Omega_u$ o bien $w \in_R \Omega_{xu}$, según el valor de $B_i$, es decir, una raíz cuadrada aleatoria módulo $N$ de $u$ o $xu$, donde $\Omega_u$ y $ \Omega_{xu}$ son el conjunto de raíces cuadradas módulo $N$ de $u$ y $xu$, respectivamente.
	\end{enumerate}
	
	\hfil
	
	La Vista de una prueba para un verificador V$^*$ cualquiera es:
	
	\begin{center}
		$Vista_{P,V^*}(x,N,h) = (x,\,N,\,h,\,U_1,\,B_1,\,W_1, \dots ,\,U_{t(n)},\,B_{t(n)},\,W_{t(n)})$.
	\end{center}
	
	
	Para simplificar la notación, escribiremos la variable aleatoria 
	
	$V_i=(U_1,\,B_1,\,W_1, \dots ,\,U_i,\,B_i,\,W_i)$.
	
	Para un V honesto, todos los $B_i$ son variables aleatorias independientes, uniformes en $\{0,1\}$. Para un V tramposo, la función $F$, probabilística en tiempo polinomial, genera los valores $b_{i+1} = F(x,N,h,v_i,u_{i+1})$, cuando $V_i = v_i$. Unimos el estudio de ambos casos suponiendo, para un V honesto, $F$ como un generador de bits aleatorio, un lanzamiento de moneda.
	
	Ahora que tenemos toda la información accesible a V$^*$ podemos construir un Simulador:
	
	\hfil 
	
	\rule{\textwidth}{1pt}
	
	\textbf{Simulador para el problema QR} $S_{V^*}(x,N,h)$.
	
	\hfil
	
	\textit{Datos}: \quad $(x,N)$, una instancia $Verdadera$ del problema QR; \quad $h$, transcripciones de ejecuciones previas del protocolo; \quad $v_i$, transcripción de la interacción actual ($i$ rondas).
	
	\textit{Ejecución}: Repetir para $i+1 \leq t(n)$:
	
	\begin{enumerate}
		\item Elegir $b_{i+1} \in_R \{0,\,1\}$
		
		\item Elegir $w_{i+1} \in_R \mathbb{Z}^*_N$
		
		\item \textbf{Si} $b_{i+1} = 0$, \textbf{entonces} calcular \qquad $u_{i+1} \equiv w_{i+1}^2 \, mod \,  N$ \\
			  \textbf{Si no}, \qquad \qquad \qquad \qquad \qquad \qquad \: $u_{i+1} \equiv w_{i+1}^2 \cdot x^{-1} \, mod \,  N$
			  
		\item \textbf{Si} $b_{i+1} = F(x,N,h,v_i,u_{i+1})$, \textbf{entonces} añadir la tupla \\ $(u_{i+1},\,b_{i+1},\,w_{i+1})$ a la transcripción. \\
			  \textbf{Si no}, volver al paso 1.
		
		\item $i = i+1$
		
	\end{enumerate}
	
	\rule{\textwidth}{1pt}
	
	\hfill
	
	El Simulador se diferencia del protocolo \ref{QRinteractive:alg} en que, en vez de elegir primero un residuo cuadrático $u_{i+1}$, elige los valores $b_{i+1}$ y $w_{i+1}$ aleatoriamente, y a partir de ellos calcula $u_{i+1}$. Entonces, una vez tiene el $u_{i+1}$ necesario para la función $F$, calcula el bit que V$^*$ hubiera enviado en una interacción real, y comprueba si es el mismo bit $b_{i+1}$ elegido. Aquí es donde vemos que el Simulador es un algoritmo probabilístico en tiempo del tipo Las Vegas (si obtenemos la tupla $i+1$, será una tupla correcta). La probabilidad de que el bit $b_{i+1}$ sea igual que el obtenido de $F$ es de $1/2$. En promedio, el Simulador necesitará dos rondas por cada tupla $(u_{i+1},\,b_{i+1},\,w_{i+1},\,)$, por lo que el tiempo de ejecución esperado es polinomial. 
	
	
	\hfil
	
	Tenemos una prueba interactiva (\ref{QRinteractive:alg}) que genera las vistas:
	
	 \begin{center}
	 	$Vista_{P,V^*}(x,N,h) = (x,N,h,U_1,B_1,W_1,\dots , U_{t(n)}, B_{t(n)}, W_{t(n)})$,
	 \end{center}
	 
	  y un Simulador que genera las transcripciones:
	  
	  \begin{center}
	  	$S_{V^*}(x,N,h)= (x,N,h,U_1^`,B_1^`,W_1^`,\dots , U_{t(n)}^`, B_{t(n)}^`, W_{t(n)}^`)$.
	  \end{center}
	
	Para terminar la demostración, veamos por inducción en $i$ que son iguales, es decir, cumplen la propiedad de \textit{conocimiento cero}.
	
	\hfil
	
	Para el caso $i=0$ ambos ensambles son constantes, $(x,N,h)=(x,N,h)$, tenemos la misma instancia e historial.
	
	\hfil
	
	Suponemos cierto el caso $i-1$, es decir, el ensamble de la Vista:
	
	 \begin{center}
		$Vista_{P,V^*}(x,N,h) = (x,N,h,U_1,B_1,W_1,\dots , U_{i-1}, B_{i-1}, W_{i-1})$,
	\end{center}
	
	es igual al del Simulador:
	
	\begin{center}
		$S_{V^*}(x,N,h)= (x,N,h,U_1^`,B_1^`,W_1^`,\dots , U_{i-1}^`, B_{i-1}^`, W_{i-1}^`)$.
	\end{center}
	
	\hfill

	Siguiendo el protocolo de la prueba interactiva, se generará la siguiente tupla de la Vista, $(U_i, B_i, W_i)$. La variable $U_i$ se elige al inicio aleatoriamente, por lo que es independiente. La v.a. $B_i$ se calcula con $F$, por lo que depende de $U_i$, $V_{i-1}$ y $h$. $W_i$ depende de ambos. La probabilidad de la tupla nos queda:
	
	\begin{flushleft}
		$P(U_i=u, B_i=b, W_i=w) = $ 	$P(U_i=u)\cdot$ \\ 
	 	$ \cdot P(B_i=b \mid V_{i-1}=v, U_i=u,h) \cdot P(W_i=w \mid U_i=u, B_i=b)$
	\end{flushleft}
	
	\hfil
	
	Sea $\alpha = \mid \mathbb{Z}^{Q+}_N \mid $, entonces $P(U_i=u) = \frac{1}{\alpha}$.
	
	Denotamos $ P(B_i=b \mid V_{i-1}=v, U_i=u,h)=p_b$, que dependerá de la $F$ utilizada.
	
	Por último, sea $\beta = \mid \Omega_u \mid = \mid \Omega_{xu} \mid $. Entonces, $P(W_i=w \mid U_i=u, B_i=0) = \frac{1}{\beta}$, $\forall w \in \Omega_u$, y $P(W_i=w \mid U_i=u, B_i=1) = \frac{1}{\beta}$, $\forall w \in \Omega_{xu}$.
	
	En total nos queda, $P(U_i=u, B_i=b, W_i=w) = \frac{p_b}{\alpha \beta}$.
	
	
	
	\hfil
	
	Ahora veamos la tupla generada por el Simulador, $(U_i^`, B_i^`, W_i^`)$. La v.a. $U_i^`$ se calcula a partir de $B_i^`$ y $W_i^`$. La variable $B_i^`$ depende de $U_i^`$, $V_{i-1}$ y $h$ por $F$ en el paso 4. Y la v.a. $W_i^`$ se elige aleatoriamente.
	
	La probabilidad de la tupla es:
	
	\begin{flushleft}
		$P(U_i^`=u, B_i^`=b, W_i^`=w) = $ 	$P(W_i^`=w)\cdot$ \\ 
		$ \cdot P(B_i^`=b \mid V_{i-1}=v, U_i^`=u,h) \cdot P(U_i^`=u \mid W_i^`=w, B_i^`=b)$
	\end{flushleft}
	
	Sabemos que $\mid \mathbb{Z}^*_N \mid = \alpha \cdot \beta $, por lo que $P(W_i^`=w) = \frac{1}{\alpha \beta}$.
	
	La probabilidad
	\marginpar{-$w\in \Omega_u \Leftrightarrow b=0$ \\-$w\in \Omega_{xu} \Leftrightarrow b=1$ \\ -$W_i^`$, $B_i^`$ indep.}
	\begin{align*}
	P(U_i^`=u)  & = P(U_i^`=u, W_i^`\in \Omega_u \cup \Omega_{xu}, B_i^` \in \{0,1\}) = \\
				&= \sum_{w\in \Omega_u} P(U_i^`=u, W_i^`=w, B_i^` = 0) + \\
				& +	\sum_{w\in \Omega_{xu}} P(U_i^`=u, W_i^`=w, B_i^` = 1) = \\
				&= \sum_{w\in \Omega_u} P(W_i^`=w)P(B_i^` = 0) + \sum_{w\in \Omega_{xu}} P(W_i^`=w)P(B_i^` = 1) = \\
				&=\beta \cdot \frac{1}{\alpha \beta} \cdot (P(B_i^`=0) + P(B_i^`=1)) = \\
				&= \frac{1}{\alpha}
	\end{align*}
	
	indica que $U_i^`$ tiene la misma distribución que $U_i$, de modo que, al calcular $b_{i} = F(x,N,h,v_{i-1},u_{i})$, se tiene 
	$P(B_i^`=b \mid V_{i-1}=v, U_i^`=u,h) = p_b$, es decir, $B_i^`$ tiene la misma distribución que $B_i$.
	
	
	Por construcción, dados $w$ y $b$, en el simulador $u$ tiene un único valor posible, $u\equiv w^2x^{-b}\,mod\,N$, por tanto, la probabilidad de que dada la tupla $(u, b, w)$, $U_i^`$ tenga el valor $u$ condicionado a que $ B_i^`=b$ y que $W_i^`=w$, es 1:
	
	$P(U_i^`=u \mid W_i^`=w, B_i^`=b) = 1$
	
	
	\hfil
	
	En total, tenemos que $P(U_i^`=u, B_i^`=b, W_i^`=w) = \frac{p_b}{\alpha \beta}$.
	
	\hfil
	
	Terminamos así la inducción en $i$ y los ensambles de la Vista y el Simulador son idénticos.
	
	\hfil
	
	Concluimos que la prueba \ref{QRinteractive:alg} del problema QR es perfecta de conocimiento cero.
	
\end{proof}



\subsection{Isomorfismo de grafos}


Otro problema de decisión del que podemos dar una prueba interactiva de conocimiento cero es el de encontrar un isomorfismo entre grafos:



\hfil

\begin{tabular}{|ll}
	\textit{Nombre:} & Problema GI (\textit{Graph Isomorphism}). \\
	\textit{Parámetros:} & Dos grafos $G_0 = (V_0, E_0)$ y $G_1 = (V_1, E_1)$, \\ & del mismo orden $\mid V_0 \mid = \mid V_1 \mid = n$. \\
	\textit{Pregunta:} & ¿Existe un isomorfismo $\pi : V_0 \rightarrow V_1$ tal que \\ & una arista $(u,v)\in E_0$ si y solo si $(\pi (u),\pi (v)) \in E_1$? \\
\end{tabular}
\\

\hfil

\begin{theorem}
	El problema GI tiene una prueba de conocimiento cero.
\end{theorem}


\begin{proof}
	
	\hfil
	
	Primero debemos dar un protocolo interactivo entre un P y un V que cumpla completitud y robustez. Después daremos un Simulador para demostrar la propiedad de conocimiento cero.
	
	\hfil

	\rule{\textwidth}{1pt}
	\begin{algorithm}[Prueba interactiva para GI]
		
		\hfil
		
		\textit{Datos comunes}: Una instancia ($G_0=(V_0,E_0)$, $G_1=(V_1,E_1)$) del Problema GI. $\mid V_0 \mid = \mid V_1 \mid = n$ es el tamaño de la instancia.
		
		\textit{Protocolo}: P calcula el isomorfismo $\tau$ entre $G_1$ y $G_0$, es decir, $\tau(G_1)=G_0$.
		
		Sea $t(n)$ un polinomio en $n$. P y V repiten $t(n)$ veces los siguientes pasos.
		
		\begin{enumerate}
			
			\item P $\rightarrow$ V :\quad $h = \pi (G_0)$, donde $\pi \in_R Sym(V_0)$.
			
			\item V $\rightarrow$ P :\quad $b \in_R \{0,\,1\}$.
			
			\item P $\rightarrow$ V :\; $\omega$,\; tal que
			\[
			\omega =
			\begin{cases}
			\pi  & si\ b = 0\\
			\pi \circ \tau  & si\ b = 1.\\
			\end{cases}
			\]
			
			\item V comprueba si:
			\[
			h \overset{?}{=}
			\begin{cases}
			\omega(G_0)  & si\ b = 0\\
			\omega(G_1)  & si\ b = 1,\\
			\end{cases}
			\]
			
			es decir, si $h$ es isomorfo a $G_b$ por $\omega$.
			
			Si la comparación falla, V termina en rechazo. En caso contrario, vuelve al paso 1.
			
			
		\end{enumerate}
		
		Tras $t(n)$ rondas, V termina y acepta la instancia como $Verdadera$, $G_0$ y $G_1$ son isomorfos.
		
		\label{GIinteractive:alg}
	\end{algorithm}
	\rule{\textwidth}{1pt}
	
	\hfil

	Sea $(G_0,G_1)$ una instancia $Verdadera$. Sea cual sea el reto $b$, P siempre puede devolver el isomorfismo $\omega$, pues $G_0$ y $G_1$ son ambos isomorfos a $h$. Tenemos que el protocolo es \textit{completo}.
	
	Si $(G_0,G_1)$ es $Falsa$, $G_0 \not\simeq G_1$, un P tramposo deberá adivinar el reto $b$ antes de calcular $h$, pues como éste debe ser un isomorfismo de $G_0$ ó $G_1$, no podrá serlo de ambos a la vez. La probabilidad de acertar el reto y mandar el isomorfismo correcto es de $1/2$ en cada ronda, por lo que la probabilidad de que un P tramposo engañe a V es de $2^{-t(n)}$. El protocolo es \textit{robusto}.
	
	\hfil
	
	Sea $(G_0, G_1)$ una instancia $Verdadera$ del problema GI. La Vista entre P y V es el ensamble
	
	\begin{align*}
		Vista_{P,V^*}(G_0, G_1, h) = (G_0, G_1, h,H_1,B_1,\Phi_1,\dots , H_{t(n)}, B_{t(n)}, \Phi_{t(n)}),
	\end{align*}

	donde la variable aleatoria $H_i$ representa el grafo isomorfo $h_i$ de la $i$-ésima ronda, la v.a. $B_i$ el reto $b_i$ de V a P, y $\Phi_i$ es el isomorfismo que envía P como respuesta al final de la ronda. El historial de anteriores transcripciones se representa con $h$.
	
	Como en el problema QR, V$^*$ podría utilizar un algoritmo probabilístico $F$, de tiempo polinomial, al calcular los retos $b_i$, para intentar obtener información de P. $F$ utilizará toda la información accesible a V$^*$ en el momento de enviar el reto.
	
	El Simulador para la prueba interactiva anterior, que utilizará el mismo algoritmo $F$, es el siguiente:
	
	
	\hfil 
	
	\rule{\textwidth}{1pt}
	
	\textbf{Simulador para el problema GI} $S_{V^*}(G_0, G_1 ,h)$.
	
	\hfil
	
	\textit{Datos}: \quad $(G_0, G_1)$, una instancia $Verdadera$ del problema GI; \quad $h$, transcripciones de ejecuciones previas del protocolo; \quad $v_i$, transcripción de la interacción actual ($i$ rondas).
	
	\textit{Ejecución}: Repetir para $i+1 \leq t(n)$:
	
	\begin{enumerate}
		\item Elegir $b_{i+1} \in_R \{0,\,1\}$
		
		\item Elegir $\pi_{i+1} \in_R Sym(V_{b_{i+1}})$ y calcular $h_{i+1}=\pi_{i+1}(G_{b_{i+1}})$.
		
		\item \textbf{Si} $b_{i+1} = F(G_0,G_1,h,v_i,h_{i+1})$, \textbf{entonces} añadir la tupla \\ $(h_{i+1},\,b_{i+1},\,\pi_{i+1})$ a la transcripción. \\
		\textbf{Si no}, volver al paso 1.
		
		\item $i = i+1$
		
	\end{enumerate}
	
	\rule{\textwidth}{1pt}
	
	\hfill
	
	
	La probabilidad de que el $b_{i+1}$ elegido coincida con el de la función $F$ es $1/2$, por lo que en promedio se necesitarán dos rondas por tupla. El Simulador es un algoritmo probabilístico que se ejecuta en un tiempo estimado polinomial.
	
	\hfil
	
	Veamos ahora que el ensamble de la $Vista_{P,V^*}(G_0, G_1 ,h)$, es igual al del Simulador, $S_{V^*}(G_0, G_1 ,h)$. Procedemos por inducción sobre $i$, el número de rondas.
	
	Para $i=0$, ambos ensambles son constantes, $Vista_{P,V^*}(G_0, G_1 ,h)$ $=$ $S_{V^*}(G_0, G_1 ,h)$ $=$ $(G_0, G_1, h)$, por lo que sus distribuciones de probabilidad son idénticas y los ensambles coinciden.
	
	Suponemos cierto para $i-1$ rondas, $P(Vista_{P,V^*}=v_{i-1}) = P(S_{V^*}=v_{i-1})$.
	
	\hfil
	
	Siguiendo el protocolo, se generarán las v.a. $(H_i, B_i, \Phi_i)$ para la $i$-ésima ronda. Utilizando el Teorema de la probabilidad compuesta, y observando la dependencia de las variables durante la ejecución del protocolo, calculamos:
	\begin{align*}
	& P(H_i=h, B_i=b, \Phi_i = \pi) = \\
	& P(\Phi_i = \pi) \cdot P(B_i = b \mid \Phi_i = \pi) \cdot P(H_i = h \mid \Phi_i = \pi, B_i=b)
	\end{align*}

	El isomorfismo $\pi$ se elige aleatoriamente entre todas las posibles permutaciones de $V_0$, como $\mid Sym(V_0) \mid = n!$, $P(\Phi_i = \pi) = \frac{1}{n!}$.
	
	La variable aleatoria $B_i$ se calcula con la función $F$, $B_i=F(h, V_i, H_i)$, por lo que asignamos la probabilidad $P(B_i = b \mid \Phi_i = \pi) = p_b$ dependiente de la $F$ que use V.

	Por último $P(H_i = h \mid \Phi_i = \pi, B_i=b) = 1$ por construcción del grafo $h$ por el isomorfismo $\pi$, independiente del valor de $B_i$.
	
	Nos queda en total que $P(H_i=h, B_i=b, \Phi_i = \pi) = \frac{p_b}{n!}$.
	
	\hfil
	
	Ahora consideramos la tupla de v.a.  $(H_i^`, B_i^`, \Phi_i^`)$ del Simulador.
	
	La variable $\Phi_i^`$ se elige aleatoriamente entre $Sym(V_0)$ o $Sym(V_1)$, ambos de mismo orden pues $\mid V_0 \mid = \mid V_1 \mid = n$, por lo que  $\mid Sym(V_0) \mid =$ $ \mid Sym(V_1) \mid =$ $ n!$, luego obtenemos $P(\Phi_i^` = \pi)=\frac{1}{n!}$.
	
	Como en la Vista, el Simulador utiliza $F$ para calcular el valor $b$ de $B_i^`$, así que $P(B_i^` = b \mid \Phi_i^` = \pi) = p_b$.
	
	Finalmente, $h$ viene determinado por $\pi$, de modo que $P(H_i^` = h \mid \Phi_i^` = \pi, B_i^`=b) = 1$.
	
	La probabilidad del Simulador nos queda $P(H_i^`=h, B_i^`=b, \Phi_i^` = \pi) = \frac{p_b}{n!}$, igual que la del ensamble de la Vista.
	
	\hfil
	
	
	Concluimos que se cumple la propiedad de \textit{conocimiento cero} y el problema GI tiene una prueba interactiva de conocimiento cero perfecta.
	
	
\end{proof}







\subsection{Logaritmo discreto}\label{perfectDL}


Vamos a expresar el problema del logaritmo discreto como un problema de decisión, donde podamos mantener cierta información secreta que no se revele en la prueba de conocimiento cero, y que permita solucionar el problema:

\hfil

\begin{tabular}{|ll}
	\textit{Nombre:} & Problema DL (\textit{Discrete Logarithm}). \\
	\textit{Parámetros:} & Un grupo cíclico $G$ de orden $q$ primo, \\ & donde se supone difícil el problema del logaritmo discreto,  \\ & un generador $g$, $G=\left\langle g \right\rangle$,\\ & y un elemento $y\in G$. \\
	\textit{Pregunta:} & ¿Conoce P el entero $s\in \mathbb{Z}_q$ tal que \\ & $g^s = y$, o equivalentemente, $log_g y = s$? \\
\end{tabular}
\\

\hfil

A la prueba interactiva asociada a este problema se les llama \textit{pruebas de conocimiento}. Veremos una prueba de conocimiento  cero de conocimiento del secreto $s$, en inglés llamadas \textit{Zero-Knowledge Proof of Knowledge}. A pesar de la verbosidad del término, se diferencian poco de las ya vistas, como vamos a ver enseguida.


\begin{theorem}
	El problema DL tiene una prueba de conocimiento cero.
\end{theorem}


\begin{proof}
	
	\hfil
	
	Primero veremos un protocolo interactivo entre P y V para probar el conocimiento de $s$, y entonces comprobaremos las tres propiedades necesarias, completitud, robustez y conocimiento cero.
	
	\hfil
	
	\rule{\textwidth}{1pt}
	\begin{algorithm}[Prueba interactiva para DL]
		
		\hfil
		
		\textit{Datos comunes}: Una instancia ($G$, $q$, $g$, $y$) del Problema DL. $n=o(g)=q$ es el tamaño del problema.
		
		\textit{Protocolo}: Sea $t(n)$ un polinomio en $n$. P y V repiten $t(n)$ veces los siguientes pasos.
		
		\begin{enumerate}
			
			\item P elige aleatoriamente $u \in_R \mathbb{Z}_q^*$.
			
			\item P $\rightarrow$ V :\quad $a = g^u$.
			
			\item V $\rightarrow$ P :\quad $b \in_R \{0,\,1\}$.
			
			\item P $\rightarrow$ V :\quad $w = (u + sb)\, mod \, q$.
			
			\item V comprueba si:
			\[
			g^w \overset{?}{=}
			\begin{cases}
			a  & si\ b = 0\\
			a\cdot y  & si\ b = 1.\\
			\end{cases}
			\]
			
			Si la comparación falla, V termina en rechazo. En caso contrario, vuelve al paso 1.
			
			
		\end{enumerate}
		
		Tras $t(n)$ rondas, V termina y acepta la instancia como $Verdadera$, P conoce el logaritmo discreto de $y \in G=\langle g \rangle $.
		\label{DLinteractive:alg}
	\end{algorithm}
	\rule{\textwidth}{1pt}
	
	\hfil
	
	
	Nótese que por el propio enunciado del problema, P no ha necesitado de su potencia ilimitada de cálculo.
	
	\hfil
	
	El protocolo es \textit{completo}, pues si P conoce $s$, siempre puede calcular un $w$ que pase la comprobación de V en el paso 5.
	
	\hfil
	
	Es también \textit{robusto}, pues suponiendo un grupo $G$ donde un P tramposo, una máquina limitada a cálculos en tiempo polinomial, no puede calcular fácilmente el secreto $s$, este P tramposo deberá intentar adivinar el reto $b$.
	
	Si P$^*$ supone que el reto $b=0$, seguirá el protocolo, mandando $w=u$, pero fallaría si V manda $b=1$, al no poder calcular el $s$.
	
	Si P$^*$ quiere superar un reto $b=1$, puede elegir $u$ como en el paso 1, enviar $a=g^u \cdot y-1$, y contestar al reto con $w=u$. Si se equivoca y V envía $b=0$, necesitaría $s$ para poder enviar el $w$ correcto y fallaría la prueba.
	
	La probabilidad de acertar el reto $b$ es de $1/2$, de modo que la probabilidad de pasar la prueba interactiva con una instancia $Falsa$ es de $2^{-t(n)}$. Se cumple la propiedad de \textit{robustez}.
	
	
	\hfil
	
	Nos queda comprobar la propiedad de \textit{conocimiento cero}.
	
	Como en casos anteriores, suponemos un algoritmo probabilístico polinomial $F$ que utiliza V$^*$ para enviar los retos. Si V fuera honesto, $F$ es un generador de números aleatorios con una distribución uniforme.
	
	
	
	\hfil 
			
	\rule{\textwidth}{1pt}
	
	\textbf{Simulador para el problema DL} $S_{V^*}(G, q, g, y, h)$.
	
	\hfil
	
	\textit{Datos}: \quad $(G, q, g, y)$, una instancia $Verdadera$ del problema DL; \quad $h$, transcripciones de ejecuciones previas del protocolo; \quad $v_i$, transcripción de la interacción actual ($i$ rondas).
	
	\textit{Ejecución}: Repetir para $i+1 \leq t(n)$:
	
	\begin{enumerate}
		\item Elegir $b_{i+1} \in_R \{0,\,1\}$
		
		\item Elegir $w_{i+1} \in_R \mathbb{Z}_q^*$.
		
		\item \textbf{Si} $b_{i+1} = 0$, \textbf{entonces} calcular \qquad $a_{i+1} = g^w$ \\
		\textbf{Si no}, \qquad \qquad \qquad \qquad \qquad \qquad \quad $a_{i+1} = g^w y^{-1} = g^{w-s}$
		
		\item \textbf{Si} $b_{i+1} = F(G, q, g, y,h,v_i,a_{i+1})$, \textbf{entonces} añadir la tupla \\ $(a_{i+1},\,b_{i+1},\,w_{i+1})$ a la transcripción. \\
		\textbf{Si no}, volver al paso 1.
		
		\item $i = i+1$
		
	\end{enumerate}
	
	\rule{\textwidth}{1pt}
	
	\hfill
	
	Por la elección aleatoria de $b_{i+1}$ y $w_{i+1}$ el Simulador es un algoritmo probabilístico, y el tiempo de ejecución estimado es de dos iteraciones por ronda simulada, pues la probabilidad de que el $b_{i+1}$ elegido coincida con el indicado por $F$ es de $1/2$.
	
	
	\hfil
	
	
	Por inducción sobre $i$, el número de rondas realizadas, veamos que los ensambles $Vista_{P,V^*}$ y $S_{V^*}$ son iguales:
	\begin{align*}
		Vista_{P,V^*} =& (G,q,g,y,h,A_1,B_1,W_1, \dots , A_i,B_i,W_i) \\
		S_{V^*} =& (G,q,g,y,h,A_1^`,B_1^`,W_1^`, \dots , A_i^`,B_i^`,W_i^`),
	\end{align*}
	donde las v.a. $A_i$, $A_i^`$ representan el testigo $a_i$ de la $i$-ésima ronda, las v.a. $B_i$, $B_i^`$ el bit del reto, y $W_i$, $W_i^`$ la respuesta de P.
	
	\hfil
	
	Para $i=0$, los ensambles $Vista_{P,V^*} = (G,q,g,y,h)$ y $S_{V^*} = (G,q,g,y,h)$ son constantes e iguales.
	
	Suponemos cierto para $i-1$.
	
	La tupla de las v.a. para la ronda $i$ en la Vista es: $(A_i,B_i,W_i)$.
	
	Su probabilidad se calcula como:
	\begin{align*}
	& P(A_i=a, B_i=b, W_i = w) = \\
	& P(A_i = a) \cdot P(B_i = b \mid A_i = a) \cdot P(W_i = w \mid A_i = a, B_i=b)
	\end{align*}
	% 1/q-1 * p_b * 1
	
	Por construcción, $a$ depende de la elección de $u$, elegido de entre $q-1$ posibles valores, $P(A_i = a) = 1/(q-1)$.
	
	V$^*$ utiliza $F(G,q,g,y,a)$ para la elección de $b$, así que podemos escribir $P(B_i = b \mid A_i = a) = p_b$, dependiente de la $F$ empleada.
	
	Finalmente, en el protocolo $w$ depende para su cálculo de $a$ y $b$, así que la probabilidad dependiente de ambos valores dados, es 1.
	
	Concluimos que $P(A_i=a, B_i=b, W_i = w) = \dfrac{p_b}{q-1}$.
	
	\hfil
	
	Observando el orden en que se calculan los valores en el Simulador, la probabilidad de la $i$-ésima tupla del Simulador es:
	\begin{align*}
	& P(A_i^`=a, B_i^`=b, W_i^` = w) = \\
	& P(W_i^` = w) \cdot P(B_i^` = b \mid W_i^` = w) \cdot P(A_i^` = a \mid W_i^` = w, B_i^`=b)
	\end{align*}
	% 1/q * p_b * 1
	
	El valor de $w_{i+1}$ se elige en $\mathbb{Z}_q^*$ independientemente de los demás. Así que $P(W_i^` = w) =  1/(q-1)$.
	
	Como antes, la elección del bit depende de $F$. $  P(B_i^` = b \mid W_i^` = w) = p_b $.
	
	Y siguiendo los pasos del Simulador, el valor de $a$ queda unívocamente determinado dados $w$ y $b$, así que $P(A_i^` = a \mid W_i^` = w, B_i^`=b) = 1$.
	
	Nos queda $ P(A_i^`=a, B_i^`=b, W_i^` = w) = \dfrac{p_b}{q-1}$, igual que la Vista, de modo que los ensambles son idénticos y queda demostrado el teorema.
	
\end{proof}


\hfil

\paragraph{Otros tipos de pruebas de conocimiento cero}

La propiedad de \textit{conocimiento cero perfecta} exige que exista un Simulador probabilístico de tiempo polinomial, cuyo ensamble sea idéntico al del protocolo. Esto limita la cantidad de pruebas de conocimiento cero conocidas, y por eso se definen pruebas con menos restricciones, que en la práctica pueden funcionar como las ZKP perfectas, en muchos casos más óptimas al reducir el número de interacciones manteniendo el nivel de robustez.

\hfil




\section{Pruebas de conocimiento cero de Verificador Honesto}\label{honestVer:sec}


% rosen2007discrete

En esta sección veremos un tipo de pruebas de conocimiento cero, utilizadas en la práctica, que derivan de las ZKP perfectas al añadir una condición al Verificador, que cumpla el protocolo indicado.

En las pruebas de conocimiento cero perfectas que hemos visto, los simuladores estudiados consideraban la existencia de una función $F$ que un Verificador tramposo V$^*$ utilizaría para elegir los retos, en un intento de obtener más información de P. Sin embargo, si el conjunto de posibles retos es demasiado grande, el Simulador diseñado perdería la propiedad de ser de \textit{tiempo polinomial}.


\begin{definition}[Propiedad de conocimiento cero con Verificador Honesto]
	\hfil
	
	Un sistema de prueba interactiva (completo y robusto), para un problema de decisión $Q$, es \textit{perfecta de conocimiento cero con Verificador Honesto} si el ensamble $Vista_{P,V}(q,h)$ es idéntico al ensamble generado por un Simulador $S_{V}(q,h)$, donde el Verificador V sigue los pasos del protocolo, para cualquier instancia $Verdadera$ $q\in Q$ y cualquier historial $h$.
\end{definition}

\hfil

Veremos es este apartado una variación de la ZKP perfecta basada en el problema del Logaritmo Discreto (\ref{perfectDL}), llamado \textit{Protocolo de Identificación de Schnorr}.

\hfil

Primero han de definirse parámetros comunes conocidos por P y V. Elegimos dos valores primos, $p$ y $q$ tal que $p\equiv 1 \, mod \, q$, es decir, $q\mid (p-1)$, y el problema del logaritmo discreto es difícil. Sea $\alpha$ un generador del subgrupo de orden $q$ de $\mathbb{Z}_p^*$. Además debemos elegir un valor $t$ que definirá la robustez del protocolo. En resumen tenemos:

\begin{itemize}
	\item $p$ primo.
	\item $q$ primo divisor de $(p-1)$.
	\item $\alpha \in \mathbb{Z}_p^*$ de orden $q$.
	\item $t$ un \textit{parámetro de seguridad}, tal que $2^t < q$. La robustez del protocolo, es decir, la probabilidad de que un P$^*$ tramposo engañe a V, será de $2^{-t}$.
\end{itemize}


El secreto de P será el valor $a$, tal que $0\leq a \leq q-1$. La prueba consistirá en demostrar que P conoce dicho valor. P calcula entonces el valor $v = \alpha ^{-a} \, mod \, p$. Éste valor se puede calcular como la inversa $\left( \alpha ^{a} \right) ^{-1} \, mod \, p$, o de manera más eficiente como $\alpha ^{q-a} \, mod \, p$.

Tanto P como V conocerán los valores $p$, $q$, $\alpha$, $t$ y $v$.

\rule{\textwidth}{1pt}
\begin{algorithm}[Schnorr]
	
	\hfil
	
	\textit{Datos comunes}: $p$, $q$, $\alpha$, $t$ y $v$.
	
	\textit{Protocolo}: Realizar una vez:
	
	\begin{enumerate}
		
		\item P elige aleatoriamente $k \in_R \mathbb{Z}_q$.
		
		\item P $\rightarrow$ V :\quad $\gamma = \alpha^k \, mod \, p$ (el \textit{testigo}).
		
		\item V $\rightarrow$ P :\quad $r$ aleatorio, tal que $1\leq r\leq 2^t < q $ (el \textit{reto}).
		
		\item P $\rightarrow$ V :\quad $y = k + ar \, mod \, q$ (la \textit{respuesta}).
		
		\item V comprueba si $\gamma \overset{?}{\equiv} \alpha^y v^r \, mod \, p$
		
		Si la comparación falla, V termina en rechazo. En caso contrario, acepta la prueba.
		
		
	\end{enumerate}
	
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil

Este algoritmo en particular se diseñó con el objetivo de minimizar la cantidad de mensajes intercambiados manteniendo una robustez que lo hiciera seguro. Como veremos, una sola interacción nos dará una probabilidad de $2^{-t}$ de que un atacante consiga engañar al Verificador.


Pero primero comprobemos la \textit{completitud}. Veamos con las siguientes congruencias que que si P conoce $a$, siempre podrá responder correctamente al reto:
\[
\alpha^y v^r \equiv \alpha ^{k+ar} v^r \equiv \alpha^{k+ar} \alpha ^{-a r} \equiv \alpha ^k \equiv \gamma \, mod \, p
\]

Por tanto, un P y V honestos finalizarán el protocolo en aceptación siempre, la prueba es \textit{completa}.

\hfil

El \textit{parámetro de seguridad} $t$ define la dificultad de adivinar el reto de V. Si P$^*$ adivinara el valor $r$ aleatorio de V, podría superar la prueba eligiendo un valor $y$ aleatorio y calculando $\gamma = \alpha ^y v ^r \, mod \, p$, con lo que enviando primero el $y$ y respondiendo al reto con $\gamma$ pasaría la prueba. La probabilidad de adivinar correctamente un reto $1\leq r\leq 2^t$ elegido aleatoriamente es de $\frac{1}{2^t}$.


Supongamos que P$^*$ puede adivinar el reto de V con una probabilidad mayor a $2^{-t}$, entonces P$^*$ conocería para un valor $\gamma$ de su elección, al menos dos respuestas posibles para dos retos distintos de V, es decir, si antes el P$^*$ tramposo podía precalcular un testigo y una respuesta para un reto de V, ahora puede calcular, para el mismo testigo (pues solo puede enviar uno antes de recibir el reto), P$^*$ conoce la respuesta de al menos dos retos.

Sea $\gamma$ el testigo para el que P$^*$ conoce los valores $r_1$, $y_1$ y $r_2$, $y_2$, un par de posibles retos y respuestas válidas, que cumplen
\[
	\gamma \equiv \alpha^{y_1} v^{r_1} \equiv \alpha^{y_2} v^{r_2} \, mod \, p
\]

Se sigue que
\[
	\alpha^{y_1 - y_2} \equiv v ^{r_2 - r_1}  \, mod \, p
\]

Como la \textit{clave pública} $v$ se calculaba como $v\equiv \alpha^{-a} \, mod \, p$, con $a$ el secreto de P, podemos sustituir:
\[
	\alpha^{y_1 - y_2} \equiv \alpha ^{-a(r_2 - r_1)}  \, mod \, p
\]

Como $\alpha$ tiene orden $q$, podemos trabajar con los exponentes como:
\[
	y_1 - y_2 \equiv a(r_1 - r_2) \, mod \, q
\]

Por la condición sobre los retos $1\leq r \leq 2^t < q$, sabemos que $0 < \mid r_2 - r_1 \mid < 2^t < q$, y como $q$ es primo, $mcd(r_2-r_1,q)=1$, de modo que existe el inverso $(r_1 - r_2)^{-1} \, mod \, q$, y el P$^*$ puede calcular el secreto $a$ como:
\[
	a = (y_1-y_2)(r_1-r_2)^{-1}\, mod \, q
\]

A partir de este análisis, vemos que cualquiera que pueda superar la prueba frente a V con una probabilidad mayor a $2^{-t}$ puede calcular el secreto de P.




\hfil



Después de ver la \textit{completitud} y \textit{robustez} del protocolo, veamos la propiedad de \textit{conocimiento cero con Verificador Honesto}.

Una transcripción o vista del protocolo es simplemente el ensamble probabilístico con una tupla:
\[
Vista_{P,V} =(\gamma, r, y)
\]

Calculamos la probabilidad 
\[
	P(\gamma=g, r=b, y=c) = P(\gamma=g)P(r=b\mid \gamma =a)P(y=c\mid \gamma=a, r=b)
\]


P calcula $\gamma$ a partir de un valor $k$ aleatorio entre $0$ y $q-1$, y elevando $\alpha$, de orden $q$ a dicho valor, de modo que la probabilidad de que $\gamma$ tome el valor $g$ es igual a la de elegir el $k$ que genera $a$: $P(\gamma=g)=\frac{1}{q}$.

Bajo el supuesto de Verificador Honesto, $P(r=b\mid \gamma =g)=P(r=b)=\frac{1}{2^t}$, pues V seguirá el protocolo, eligiendo el reto aleatoriamente, sin usar la función $F$ del apartado anterior.

Finalmente, $y=k+ar$ depende del $k$ que genera $\gamma=g$, del secreto $a$ de P y del reto $r=b$ de V. La probabilidad condicionada $P(y=c\mid \gamma=a, r=b)=1$.

Tenemos que la probabilidad de obtener la Vista $(\gamma, r, y)$ es de $\frac{1}{q\cdot 2^{t}}$.

\hfil

Ahora definimos el Simulador de la prueba, con la restricción de Verificador Honesto:


\rule{\textwidth}{1pt}
\begin{algorithm}
	
	\hfil
	
	\textit{Datos}: $p$, $q$, $\alpha$, $t$ y $v$.
	
	\textit{Protocolo}: Realizar una vez:
	
	\begin{enumerate}
		
		\item Elegir $r$ aleatorio tal que $1\leq r \leq 2^t$.
		\item Elegir $y$ aleatorio tal que $0\leq y \leq q-1$.
		\item Calcular $\gamma = \alpha ^y v^r \, mod \, p$.		
		
	\end{enumerate}
	
\end{algorithm}
\rule{\textwidth}{1pt}


El ensamble del Simulador se puede escribir como el conjunto:
\[
S_{V} = \{ (\gamma', r', y') : 1\leq r' \leq 2^t,\, 0\leq y'\leq q-1,\, \gamma' \equiv \alpha^y v^r \, mod \, p \}
\]

Como $\gamma'$ depende totalmente de $r'$ e $y'$, $\mid S_V \mid = q\cdot 2^t$, es decir, $P(\gamma'=g, r'=b, y'=c)=\frac{1}{q\cdot 2^t}$, la misma que la de la Vista. 


Tenemos, por tanto, que el protocolo de Schnorr es una Prueba de Conocimiento Cero con Verificador Honesto.

\hfil

A día de hoy, para probar que Schnorr es ZKP perfecta, donde un Verificador utiliza la función $F$ que elige los retos no uniformemente entre $1$ y $2^t$, no se conoce ningún simulador que sea probabilístico en tiempo polinomial, condición indispensable para probar que es perfecta.


%%%%%%%%
Aún así, Schnorr es utilizado ampliamente en la práctica, pues tampoco se conoce ningún ataque a partir de la elección de retos no aleatorios. Para probar que el protocolo es una ZKP perfecta hay que añadir nuevas restricciones, como reducir el espacio de retos, a cambio de incrementar las rondas para mantener el nivel de robustez. Con un bit por reto y $t$ rondas, en la sección anterior demostramos que el protocolo era una ZKP perfecta, pero en la práctica es poco eficiente por la cantidad de mensajes necesarios.
%%%%%%%%%


\hfil

\section{Pruebas de conocimiento cero estadísticas}

\hfil

Se denominan así las pruebas interactivas con un Simulador que, en vez de tener ensamble idéntico a la Vista, convergen en $n$, el parámetro que define el tamaño del problema:
\begin{center}
	$$
	\lim_{n\to\infty} Vista_{P,V^*}(q,h) =  \lim_{n\to\infty} S_{V^*}(q,h)
	$$
\end{center}

para toda instancia $Verdadera$ $q\in Q$, donde $n$ es el tamaño de la instancia $q$, e historial $h$. 

\hfil
% TODO: ejemplo, referenciar textos de transformar estadísticas o algo


\section{Esquemas de compromiso}\label{bitcommitment}

En las pruebas de conocimiento cero vistas hasta ahora, el primer mensaje del Probador consistía en un \textit{compromiso} con el Verificador, al que llamamos \textit{testigo}, de modo que en la respuesta al reto no pudiera engañarle, con cierta probabilidad.


Antes de introducir el último tipo de Pruebas de Conocimiento Cero de este capítulo, las Computacionales, debemos estudiar la existencia y propiedades de los llamados esquemas de compromiso, una herramienta que nos permite dar para todo problema \textbf{NPC} una Prueba de Conociemiento Cero Computacional, como muestra Manuel Blum en \citetitle{blum} \citep{blum}.

Estos esquemas permiten esconder la estructura de una instancia $Verdadera$, donde P se compromete con su \textit{testigo} antes de conocer el \textit{reto} de V, de modo que V no puede obtener información de estos testigos. En la última \textit{respuesta} de P, se revelará una pequeña parte de la estructura de la instancia $Verdadera$, de la cual V no podrá aprender tampoco nada.


Empecemos definiendo un esquema de compromiso para un bit:


\begin{definition}\label{commit:def}
	Un esquema de compromiso de un \textit{bit} es un par de funciones $(f,v)$ de tiempo polinomial. La función
	
	$
	f:\{0,1\}\, x\, \Upsilon \to \chi
	$
	\\transforma el bit $b\in \{0,1\}$ con una clave aleatoria $y\in \Upsilon$. El valor $x=f(b,y)$ lo llamaremos \textit{blob} o \textit{testigo} de $b$. La función de verificación
	
	$
	v:\chi \, x \, \Upsilon \to \{0,1,\bullet\}
	$
	\\abre el blob revelando el bit $b$, o indicando que no es un par (blob,clave) válido.
	
	El par $(f,v)$ debe cumplir la siguientes condiciones:
	\begin{enumerate}
		\item \textit{Vinculación}: Para todo blob $x=f(b,y)$, P no es capaz de encontrar un valor $y' \neq y$ tal que el blob se puede abrir con otro valor, es decir, $v(x,y) \neq v(x,y')$.
		
		\item \textit{Secreto}: Los ensambles $\{f(0,\Upsilon)\}$ y $\{f(1,\Upsilon)\}$ son indistinguibles.
	\end{enumerate}
	
\end{definition}


Podemos clasificar los esquemas de compromiso de bit en dos tipos:

\begin{itemize}
	\item \textbf{Vinculación incondicional}: significa que incluso un P con una capacidad computacional ilimitada (como en las pruebas interactivas) no puede cambiar el bit comprometido en el \textit{testigo} enviado.
	
	\item \textbf{Secreto incondicional}: dado un V con capacidad computacional ilimitada, no es capaz de obtener información alguna del testigo, es decir, no es capaz de distinguir los ensambles con mayor probabilidad que eligiendo al azar el posible valor de $b$.
	
\end{itemize}


En un entorno donde tenemos dos interlocutores, P y V, que ven todo lo que el otro les envía, es imposible tener vinculación y secreto incondicionales a la vez. Supongamos que tenemos vinculación incondicional, P no puede encontrar un valor $y'$ que abra $x$ con un bit diferente. Entonces V podría distinguir a qué $b$ corresponde el testigo $x$ recibido, siendo el algoritmo más fácil probar todos los valores $y'\in \Upsilon$ hasta encontrar el que hace $ v(x,y') \neq \bullet$. Aunque una máquina convencional podría tardar demasiado tiempo, estamos suponiendo que V puede ser computacionalmente ilimitado para considerar secreto incondicional, y por tanto, queda demostrado que no podemos tener ambas propiedades a la vez.

Sin embargo, se puede conseguir vinculación o secreto computacional. Al igual que en las pruebas de conocimiento cero computacionales, aquí cambiamos la condición de máquinas computacionalmente ilimitadas por máquinas convencionales, y consideramos que no existe ningún algoritmo probabilístico en tiempo polinomial que pueda, o bien encontrar un $y'$ que permita a P cambiar el bit comprometido (vinculación), o bien que permita a V obtener el valor de $b$ sin la clave $y$ (secreto).

Para conseguir vinculación y secreto incondicionales a la vez, han de utilizarse otras técnicas de comunicación, como canales con ruido o múltiples participantes \citep{damgardcommitment, crepeau1997efficient, ben1988completeness, chaum1988multiparty, crepeau1988achieving}.

\hfil


\subsection{Esquemas de compromiso con secreto incondicional}

En este apartado vamos a mostrar ejemplos de esquemas de compromiso de bit que consiguen secreto incondicional y vinculación computacional, basándose en los mismos problemas vistos para las pruebas de conocimiento perfectas: residuos cuadráticos, logaritmo discreto e isomorfismo de grafos.

\hfil

El esquema basado en residuos cuadráticos lo inicia V, eligiendo el módulo $n=pq$ producto de dos primos, de modo que el problema QR módulo $n$ es impracticable para P. V además elige un $t\in_R \mathbb{Z}_n^*$ para calcular el residuo $s=t^2\,mod\,n$. El par $(s,n)$ se hace público para que P lo utilice. Utilizaremos como conjunto de \textit{claves} $\Upsilon = \mathbb{Z}_n^*$ y como conjunto de los posibles blobs o testigos $\chi = \mathbb{Z}_n^{Q+}$, los residuos cuadráticos.

El algoritmo de compromiso es como sigue:



\hfil

\rule{\textwidth}{1pt}
\begin{algorithm}[Compromiso de bit basado en residuos cuadráticos]\label{commitQRsec:alg}
	\hfil
	
	\textit{Ocultación}: P elige al azar $y\in \mathbb{Z}_n^*$ y oculta el bit $b$ como:
	\[x = f(b,y) = s^b y^2 \, mod \, n \]
	
	\textit{Apertura}: P envía a V el valor $y$. V calcula el bit $b$:
	\[ b = v(x,y) = 
	\begin{cases}
	0  & si\ x\equiv y^2 \, mod \, n  \\
	1 & si\ x\equiv s\cdot y^2 \, mod \, n\\
	\bullet & en\ otro\ caso.
	\end{cases}
	\]
	\label{bitcommitQR:alg}
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil


La ocultación consiste en enviar como testigo un residuo cuadrático módulo $n$, y a la hora de desvelar el valor del bit, P debe desvelar una raíz cuadrada de $x$. Si P es una máquina limitada polinomialmente, al no conocer la factorización de $n$, no podrá calcular la raíz cuadrada de $x$. Si pudiera calcular dicha raíz, un ataque consistiría en seguir el protocolo para el bit $b=1$, de modo que conocemos el $y$ para abrirlo como $1$, y cuando P quiera cambiar el bit oculto a $0$, calculará la raíz cuadrada módulo $n$ de $s\cdot y^2$, de modo que V obtendrá en la \textit{apertura} $b=0$. De este modo, tenemos \textbf{vinculación computacional}.

Por otro lado, si P elige de modo aleatorio $y\in \mathbb{Z}_n^*$, como los ensambles probabilísticos $\{f(0,\Upsilon)\}$ y $\{f(1,\Upsilon)\}$ son idénticos, tenemos \textbf{secreto incondicional}. Un V \textit{todopoderoso} computacionalmente no podría distinguirlos, ni al calcular todas las raíces modulares del testigo $x$ recibido, pues o bien una de esas raíces es el $y$ escogido por P, o bien una de ellas corresponde al valor $t\cdot y \, mod \, n$.


\hfil


A continuación, presentamos otro esquema de compromiso basado en el logaritmo discreto, conocido como \textit{compromiso de Pedersen}. Para llevarlo a cabo, P y V deben primero decidir un $p$ primo suficientemente grande y un generador $g\in \mathbb{Z}_p^*$ donde el problema del logaritmo discreto es \textit{difícil}. V además elige un valor aleatorio $s\in \mathbb{Z}_{p-1}$, de modo que no se conoce $log_g s$, y lo envía a P. Los conjuntos del esquema de compromiso son $\Upsilon = \mathbb{Z}_{p-1}$ para las \textit{claves} y $\chi= \mathbb{Z}_p^*$ para los blobs.





\hfil

\rule{\textwidth}{1pt}
\begin{algorithm}[Compromiso de bit basado en logaritmo discreto]
	\hfil
	
	\textit{Ocultación}: P elige al azar $y\in \Upsilon$ y oculta el bit $b$ como:
	\[x = f(b,y) = s^b g^y \, mod \, p \]
	
	\textit{Apertura}: P envía a V el valor $y$. V calcula el bit $b$:
	\[ b = v(x,y) = 
	\begin{cases}
	0  & si\ x\equiv g^y \, mod \, p  \\
	1 & si\ x\equiv s g^y \, mod \, p \\
	\bullet & en\ otro\ caso.
	\end{cases}
	\]
	\label{bitcommitDL:alg}
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil

El posible ataque a este esquema de compromiso consistiría en calcular el logaritmo discreto de $s$ módulo $p$, llamémoslo $t$, $g^t=s\,mod\,p$. Si P oculta $b=0$, enviará $x=g^y\,mod\,p$, y para poder abrir al valor $b=1$ puede enviar a V $y-t$, de modo que V calculará $sg^{y-t}\equiv g^t g^{y-t} \equiv g^y \equiv x \, mod \, p$, obteniendo $b=1$. En el caso contrario, donde P oculta $b=1$, enviará $x=sg^y\,mod\, p$ a V como testigo, y para abrir el bit como $b=0$ basta con enviar $y+t$, tal que V calculará $g^{y+t}\equiv g^t g^y \equiv s g^y\, mod\, p$, creyendo entonces que $b=1$.

Como antes, si P es computacionalmente limitado, no podrá resolver el problema del logaritmo discreto y obtenemos una \textbf{vinculación computacional}. También tenemos como antes que los ensambles $\{f(0,\Upsilon)\}$ y $\{f(1,\Upsilon)\}$ son iguales, pues los exponentes se distribuyen uniformemente en $\mathbb{Z}_{p-1}$, y por tanto el esquema es de \textbf{secreto incondicional}.



\hfil

Finalmente utilizamos el problema del isomorfismo de grafos para mostrar otro esquema de secreto incondicional. En este caso P y V escogen un grafo $G=(V,E)$ ($n=\mid V \mid $). V escoge al azar una permutación $\pi \in_R Sym(V)$ del grafo y calcula $H=\pi(G)$. El par de grafos $(G,H)$ lo conocerán tanto P como V, pero la permutación $\pi$ la mantendrá en secreto V. Los conjuntos del esquema de compromiso son $\Upsilon = Sym(V)$ y $\chi = \{ H \mid H=\pi(G),\, \pi\in_R Sym(V) \}$.


\hfil

\rule{\textwidth}{1pt}
\begin{algorithm}[Compromiso de bit basado en isomorfismo de grafos]
	\hfil
	
	\textit{Ocultación}: P elige al azar $\gamma \in \Upsilon$ y oculta el bit $b$ como:
	\[X = f(b,\gamma) = 
	\begin{cases}
	\gamma(G) & si\ b=0 \\
	\gamma(H) & si\ b=1 \\
	\end{cases}
	\]
	
	\textit{Apertura}: P envía a V el valor $\gamma$. V calcula el bit $b$:
	\[ b = v(X,\gamma) = 
	\begin{cases}
	0  & si\ \gamma(G)=X \\
	1 & si\ \gamma(H)=X \\
	\bullet & en\ otro\ caso.
	\end{cases}
	\]
	\label{bitcommitGI:alg}
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil

P podría atacar el esquema si conociera el isomorfismo de $G$ a $H$, componiéndolo con $\gamma$ para cambiar el bit que V abriría. Como suponemos que P es una máquina limitada computacionalmente, no puede resolver el problema del isomorfismo de grafos y por tanto el esquema de compromiso es de \textbf{vinculación computacional}. Además, como los posibles $\gamma$ para abrir un bit son permutaciones aleatorias de $G$, compuestas o no con $\pi$, los ensambles $\{f(0,\Upsilon)\}$ y $\{f(1,\Upsilon)\}$ son idénticos, de modo que tenemos \textbf{secreto incondicional}.



\subsection{Esquemas de compromiso con vinculación incondicional}

Podemos conseguir esquemas de compromiso con vinculación incondicional a costa de obtener secreto computacional, como demostramos antes, no podemos obtener ambas propiedades a la vez de modo incondicional. Veremos en este apartado un ejemplo basado en residuos cuadráticos.

\hfil

Partiendo del problema del residuo cuadrático, para $N=pq$, los conjuntos $\mathbb{Z}_N^{Q+}$ y $\mathbb{Z}_N^{Q-}$ son polinomialmente indistinguibles. En este caso, P inicia el esquema 
eligiendo 2 primos aleatorios suficientemente grandes, $p$ y $q$, y un \textbf{no}-residuo cuadrático $s\in \mathbb{Z}_N^{Q-}$, es decir, con símbolo de Jacobi $1$. El par $(s,N)$ se hace público para V. El conjunto de \textit{claves} del esquema es $\Upsilon = \mathbb{Z}_N^*$, y el de posibles valores de los blobs es $\chi = \mathbb{Z}_N^Q$, los valores con símbolo de Jacobi $1$, sea o no residuo cuadrático.



\hfil

\rule{\textwidth}{1pt}
\begin{algorithm}[Compromiso de bit basado en residuos cuadráticos]\label{commitQRbind:alg}
	\hfil
	
	\textit{Ocultación}: P elige al azar $y\in \mathbb{Z}_N^*$ y oculta el bit $b$ como:
	\[x = f(b,y) = s^b y^2 \, mod \, N \]
	
	\textit{Apertura}: P envía a V el valor $y$. V calcula el bit $b$:
	\[ b = v(x,y) = 
	\begin{cases}
	0  & si\ x\equiv y^2 \, mod \, N  \\
	1 & si\ x\equiv s\cdot y^2 \, mod \, N \\
	\bullet & en\ otro\ caso.
	\end{cases}
	\]
	\label{bitcommitQR2:alg}
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil


El valor del testigo $x$ será un residuo cuadrático si $b=0$, o un no-residuo cuadrático si $b=1$, y como $ \mathbb{Z}_N^{Q+} \cap \mathbb{Z}_N^{Q-} = \emptyset $, P es incapaz de abrir el testigo con otro valor de $b$, aunque sea computacionalmente ilimitado. Tenemos por tanto \textbf{vinculación incondicional}.

Sin embargo, los ensambles $\{f(0,\Upsilon)\}$ y $\{f(1,\Upsilon)\}$ son sólo polinomialmente indistinguibles, bajo la suposición de que el problema QR es \textit{difícil}, de modo que obtenemos sólo \textbf{secreto computacional}.

Este esquema es casi idéntico al \ref{bitcommitQR:alg}, pero la diferencia radica en que en el esquema con secreto incondicional, sólo usamos residuos cuadráticos, de modo que no se podía distinguir una apertura de otra hasta que la enviara P, y en este caso utilizamos un no-residuo cuadrático con símbolo de Jacobi $1$, y en vez de secreto incondicional, conseguimos vinculación incondicional.

%TODO: aquí el concepto de cifrado estadístico

\hfil

\subsection{Esquemas de compromiso para cadenas de bits}

Existen pruebas interactivas donde P necesita comprometerse con un valor en un conjunto mayor que $\{0,1\}$, de modo que para ocultarlo, con las técnicas previas, debería representar en base binaria dicho valor y ejecutar el esquema de compromiso bit a bit, lo cual es claramente ineficiente. Vamos a ampliar la definición \ref{commit:def}:

\begin{definition}\label{commit:def2}
	Un esquema de compromiso de un cadenas de $n$ bits es un par de funciones $(f,v)$ de tiempo polinomial. La función
	
	$
	f:\{0,1\}^n\, x\, \Upsilon \to \chi
	$
	\\transforma la cadena $s=(b_1,\dots,b_n)\in \{0,1\}^n$ con una clave aleatoria $y\in \Upsilon$. El valor $x=f(b,y)$ lo llamaremos \textit{blob} o \textit{testigo} de $s$. La función de verificación
	
	$
	v:\chi \, x \, \Upsilon \to \{0,1,\dots,2^{n-1}\bullet\}
	$
	\\abre el blob revelando la cadena $s$, o indicando que no es un par (blob,clave) válido.
	
\end{definition}

\hfil

Veamos dos ejemplos basados en el problema del logaritmo discreto. El primero se basa en el compromiso de Pedersen, siendo de secreto incondicional, mientras que en el segundo ejemplo, basado en el algoritmo de ElGamal, conseguimos vinculación incondicional.


\hfil

Comencemos por el compromiso de Pedersen. Como antes, P y V deben elegir un primo $p$ suficientemente grande para que el problema del logaritmo discreto sea impracticable. Además, eligen un generador $g\in \mathbb{Z}_p^*$ y un valor aleatorio $h$ tal que no se conoce $log_g h$. El conjunto de \textit{claves} será $\Upsilon = \mathbb{Z}_{p-1}$ y el de blobs $\chi = \mathbb{Z}_p^*$. El compromiso de una cadena $s$ se obtiene como sigue:


\hfil

\rule{\textwidth}{1pt}
\begin{algorithm}
	\hfil
	
	\textit{Ocultación}: P elige al azar $y\in \Upsilon$ y oculta $s$ como:
	\[x = f(s,y) = g^s h^y \, mod \, p \]
	
	\textit{Apertura}: P envía a V el par $(s',y')$. V comprueba que
	\[ s = v(x,y) = 
	\begin{cases}
	s' & si\ x\equiv g^{s'} h^{y'} \, mod \, p  \\
	\bullet & en\ otro\ caso.
	\end{cases}
	\]
	\label{bitscommitDL:alg}
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil

Para poder romper la propiedad de vinculación, haría falta encontrar los pares $(s_0,y_0)$ y $(s_1,y_1)$, con $s_0\neq s_1$, tal que
\[
g^{s_0}h^{y_0} \equiv g^{s_1}h^{y_1}\, mod \, p
\]
operando obtenemos $g^{s_0-s_1}\equiv h^{y_1-y_0}\, mod \, p$, y podemos despejar 
\[
h \equiv g^{ (s_0-s_1) (y_1-y_0)^{-1} \, mod\, p-1 } \, mod \, p
\]
y habríamos calculado el logaritmo discreto de $h$ en base $g$, pero para un P computacionalmente limitado, y suponiendo el problema del logaritmo discreto, esto no es posible, por lo que obtenemos \textbf{vinculación computacional}.


Por otra parte, el exponente aleatorio $y$ se elige uniformemente en $\mathbb{Z}_{p-1}$, de modo que el valor $g^s h^y \, mod \, p$ también se distribuye uniformemente en $\mathbb{Z}_p^*$. Se puede ver que dado cualquier par $(s,y)$ y cualquier posible valor $s'$, existe $y'$ tal que $g^s h^y \equiv g^{s'} h^{y'}\, mod \, p$: si $h\equiv g^t\, mod \, p$, tenemos que cualquier $s'$ se puede abrir con la \textit{clave} $y' = \frac{s-s'}{t} + y$. Tenemos entonces que el esquema es de \textbf{secreto incondicional}.


\hfil

Ahora veamos el segundo ejemplo de compromiso de cadenas de bits. La inicialización es la misma que en el caso anterior, P y V conocen un primo $p$, un generador $g\in \mathbb{Z}_p^*$ y un valor aleatorio $h\in \mathbb{Z}_p^*$ tal que no se conoce $log_b h$. Los conjuntos del esquema de compromiso son $\Upsilon = \mathbb{Z}_{p-1}$ y $\chi = \mathbb{Z}_p^*$.

\hfil

\rule{\textwidth}{1pt}
\begin{algorithm}
	\hfil
	
	\textit{Ocultación}: P elige al azar $y\in \Upsilon$ y oculta $s$ como el par de valores:
	\[(x_1,x_2) = f(s,y) = ( g^y \, mod \, p ,\, g^sh^y \, mod \, p) \]
	
	\textit{Apertura}: P envía a V el par $(s',y')$. V comprueba que
	\[ s = v(x,y) = 
	\begin{cases}
	s' & si\ x_1\equiv g^{y'} \, mod \, p  \quad y \quad x_2\equiv  g^{s'}h^{y'} \, mod \, p \\
	\bullet & en\ otro\ caso.
	\end{cases}
	\]
	\label{bitscommitDL2:alg}
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil


En este caso, el valor de $x_1 = g^y \, mod \, p$ determina unívocamente el valor de $y$ elegido por P, y de este modo se fija el posible valor de $s$ en $g^s h^y\, mod\, p$. Obtenemos así \textbf{vinculación incondicional}.

A cambio, siguiendo el mismo razonamiento que en el algoritmo anterior para su secreto incondicional, como ahora el posible valor de $y$ es único, un V con suficiente capacidad computacional podría resolver el logaritmo discreto y obtener $y$ y $s$ antes de que P realice la apertura. Sin embargo, ante un V limitado, y suponiendo que el problema del logaritmo discreto es \textit{difícil}, obtenemos \textbf{secreto computacional}.


Una ventaja de este esquema frente al anterior, es que P puede elegir el valor de $h$ por su cuenta, sin que V desconfíe de si conoce o no su logaritmo discreto. En el caso anterior, si P calcula maliciosamente $h$ como $h=g^t\,mod\,p$, hemos visto que puede abrir un blob con el valor que quiera. En este esquema, gracias a la vinculación incondicional, aunque P conozca $t$, no puede romper el esquema de compromiso. 

\hfil



\hfil

Para finalizar este capítulo, veamos las implicaciones de estos dos tipos de esquemas de compromiso existentes, los de secreto o vinculación incondicional, sobre las pruebas de conocimiento cero.

Cuando tratamos con un esquema de compromiso de vinculación incondicional, podemos trabajar incluso con un P de capacidad computacional ilimitada, como en las pruebas de conocimiento cero perfectas, y V estará seguro de que no se le engaña al abrir el testigo presentado. Sin embargo, desde la perspectiva de P, los blobs que no se abren, y deben ocultar la información, pueden verse comprometidos en el futuro si los problemas en los que se basa la propiedad de secreto computacional consiguen resolverse, bien para el caso general, o bien para las instancias de una cierta interacción pasada.

Por otro lado, si utilizamos esquemas de compromiso con secreto incondicional, P puede estar seguro de que los valores no revelados se mantendrán seguros en el futuro. Sin embargo, cuando un V se enfrenta a un P \textit{todopoderoso}, la confianza en que P no cambiará el valor comprometido desaparece. Por eso, este tipo de compromisos sólo se pueden utilizar cuando en la prueba interactiva estudiada P no precisa de ser computacionalmente ilimitado.






\section{Pruebas de conocimiento cero computacionales}

% TODO revisar con computational
Decimos que dos ensambles probabilísticos son \textit{indistinguibles polinomialmente} si no existe un \textit{algoritmo probabilístico en tiempo polinomial} que puede distinguir uno de otro. Se puede consultar más sobre indistinguibilidad polinomial en \citep{book:856771}, donde se indica que, en particular, es un subconjunto propio de la \textit{indistinguibilidad estadística}, que nos daba las Pruebas de Conocimiento Cero Estadísticas del apartado anterior.

\hfil



\begin{definition}[Propiedad de conocimiento cero computacional]
	\hfil
	
	Un sistema de prueba interactiva (completo y robusto), para un problema de decisión $Q$, es \textit{de conocimiento cero computacional} si el ensamble $Vista_{P,V^*}(q,h)$ es indistinguible polinomialmente al ensamble generado por un Simulador $S_{V^*}(q,h)$, para cualquier instancia $Verdadera$ $q\in Q$ y cualquier historial $h$.
\end{definition}

\hfil


Para las pruebas que veremos en esta sección utilizaremos esquemas de compromiso con vinculación incondicional, y por tanto, secreto computacional. El esquema en particular utilizado en cada algoritmo es arbitrario mientras cumpla la propiedad, de modo que denominaremos a un blob como una \textit{caja negra} $C$ que oculta un cierto valor, y lo desvela entregando su \textit{llave} a V.


En esta clase de ZKP se encuentran problemas como el del camino hamiltoniano (HC), o el de la 3-coloración del grafo (G3C).


\subsection{Prueba de conocimiento cero para un grafo hamiltoniano}

Dado el problema de decisión del grafo hamiltoniano, mostramos el algoritmo descrito por \citeauthor{blum} en \citep{blum}:

\begin{tabular}{|ll}
	\textit{Nombre:} & Problema HC. \\
	\textit{Parámetros:} &Un grafo $G=(V,E)$. \\
	\textit{Pregunta:} & ¿Existe un ciclo en G que recorre pasa por\\& cada vértice en V una única vez? \\
\end{tabular}
\\

\hfil

\rule{\textwidth}{1pt}
\begin{algorithm}[Prueba interactiva para HC]
	
	\hfil
	
	\textit{Datos comunes}: Una instancia $G=(V,E)$ del Problema HC. $\mid V \mid = n$ es el tamaño del problema.
	
	\textit{Protocolo}: 
	
	P encuentra un ciclo hamiltoniano de $G$. Usará el mismo ciclo durante el resto de la prueba.
	
	Sea $t(n)$ un polinomio en $n$. P y V repiten $t(n)$ veces los siguientes pasos.
	
	\begin{enumerate}
		
		\item P oculta $G$ en cajas negras: asocia, de manera uniformemente aleatoria, los vértices $v_1, v_2, \dots v_n$ a las cajas $C_1, C_2, \dots C_n$ (una permutación sobre los vértices del grafo); además, para cada par de cajas $(C_i,C_j)$ prepara otra caja llamada $C_{ij}$ que guardará un $1$ si los vértices ocultos en $C_i$ y $C_j$ son adyacentes, ó $0$ en caso contrario.
		
		\item P $\rightarrow$ V :\quad $n + \binom{n}{2}$ cajas negras: $C_1, C_2, \dots C_n, C_{1,2},\dots, C_{n-1,n}$
		
		\item V $\rightarrow$ P :\quad $b \in_R \{0,\,1\}$.
		
		\item Si $b=0$, P envía las llaves para abrir todas las cajas.
		
		Si $b=1$, P abre exactamente $n$ cajas, $C_{ij}, C_{jk}, C_{kl}, \dots C_{l^`i}$, que corresponden al ciclo hamiltoniano escondido por los vértices escondidos en las cajas $C_1, C_2, \dots C_n$.
		
		\item Si $b=0$, V comprueba que el grafo descubierto por las cajas sea G.
		
		Si $b=1$, V comprueba que los índices de las cajas  $C_{ij}, C_{jk}, \dots C_{l^`i}$ forman un ciclo y que todas contienen un $1$.
		
		Si la comprobación falla, V termina en rechazo. En caso contrario, vuelve al paso 1.
		
		
	\end{enumerate}
	
	Tras $t(n)$ rondas, V termina y acepta la instancia como $Verdadera$, $G$ es hamiltoniano.
	\label{HCinteractive:alg}
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil


El protocolo es \textit{completo}, pues si el grafo es en verdad hamiltoniano, P todopoderoso computacionalmente podrá encontrar un ciclo, y siguiendo el algoritmo, siempre podrá descubrir G o el ciclo elegido, cuando V lo pida.

Si un P$^*$ tramposo no conoce un ciclo hamiltoniano de $G$, puede intentar adivinar cuándo V pedirá descubrir el grafo o el ciclo. En el primer caso, seguirá el protocolo, ocultando $G$ en las cajas negras. En el segundo caso, P$^*$ sólo debe elegir un ciclo de cajas  $C_{ij}, C_{jk}, \dots C_{l^`i}$ donde introducirá el valor $1$, haya o no una arista uniendo los vértices en $G$. Si V pide descubrir el ciclo, P$^*$ revelará un ciclo hamiltoniano, pero no del grafo $G$.

Si P$^*$ no acierta correctamente qué bit enviará V, en cada ronda hay una probabilidad de $1/2$ de que V pille a P$^*$ en su mentira. Ejecutando el protocolo $t(n)$ veces, la probabilidad de que un P$^*$ tramposo engañe a V es de $2^{-t(n)}$, por tanto, la prueba es \textit{robusta}.

Veamos ahora un simulador para el protocolo anterior. Como en las pruebas anteriores, suponemos que V$^*$ utiliza una función probabilística en tiempo polinomial $F$ que con la información disponible elige el bit $b$ del reto de manera no uniforme.

\hfil 

\rule{\textwidth}{1pt}

\textbf{Simulador para el problema HC} $S_{V^*}(G=(V,E), h)$.

\hfil

\textit{Datos}: \quad $G$, una instancia $Verdadera$ del problema HC; $h$, transcripciones de ejecuciones previas del protocolo; $v_i$, transcripción de la interacción actual ($i$ rondas).

\textit{Ejecución}: Repetir para $i+1 \leq t(n)$:

\begin{enumerate}
	\item Elegir $b_{i+1} \in_R \{0,\,1\}$
	
	\item \textbf{Si} $b_{i+1} = 0$, \textbf{entonces} oculta $G$ en una permutación aleatoria de cajas negras. \\
	\textbf{Si no}, oculta un n-ciclo cualquiera en cajas negras.\\
	En ambos casos produce las cajas negras $C_1^{i+1}, \dots, C_{n-1,n}^{i+1}$.\\
	
	\item \textbf{Si} $b_{i+1} = F(G,h,v_i,C_1^{i+1}, \dots, C_{n-1,n}^{i+1})$, \textbf{entonces} añadir la tupla \\ $(C_1^{i+1}, \dots, C_{n-1,n}^{i+1},b_{i+1},K_{i+1})$ a la transcripción, donde $K_{i+1}$ es el conjunto de claves para abrir las cajas, según el valor $b_{i+1}$. \\
	\textbf{Si no}, volver al paso 1.
	
	\item $i = i+1$
	
\end{enumerate}

\rule{\textwidth}{1pt}

\hfill

Al haber una probabilidad de $1/2$ de que el bit $b_{i+1}$ coincida con el valor de la función $F$, el simulador es probabilístico, con un tiempo estimado de ejecución de 2 iteraciones por cada una de las $t(n)$ rondas, de modo que es de tiempo polinomial.

Tenemos los ensambles probabilísticos 
\begin{center}
	$Vista_{P,V^*}(G,h) = (G,h,E_1,B_1,K_1,\dots , E_{t(n)}, B_{t(n)}, K_{t(n)})$,
\end{center}
y 
\begin{center}
	$S_{V^*}(G,h) = (G,h,E_1',B_1',K_1',\dots , E_{t(n)}', B_{t(n)}', K_{t(n)}')$.
\end{center}
donde $E_i$ y $E_i'$ son las variables aleatorias que representan las cajas negras del compromiso, $B_i$ y $B_i'$ las v.a. de los bits elegidos por V en el reto, y $K_i$ y $K_i'$ las v.a. de las llaves reveladas.

Por inducción sobre $i$, cuando $i=0$, los ensambles corresponden a la misma tupla $(G,h)$, de modo que son idénticos.

Continuamos la inducción suponiendo que para $i-1$ los ensambles son indistinguibles computacionalmente. 

Analizando la prueba interactiva \ref{HCinteractive:alg}, en la interacción $i$, cuando V elige $b_{i}=0$, éste obtiene de P una de las $n!$ posibles permutaciones del grafo $G$, y si V eligiera $b_i=1$, obtendría un $n$-ciclo aleatorio, de los $n!$ posibles también, pues P forma dicho $n$-ciclo de cajas negras a partir de un ciclo hamiltoniano prefijado y la permutación aleatoria aplicada a $G$. La probabilidad de descubrir todo $G$ o un $n$-ciclo depende de la elección de $b_i$, cuya probabilidad viene determinada por $F$.

Del mismo modo, analizando el simulador,  $F$ determinará la probabilidad de que en la transcripción aparezca un $0$ o un $1$ en el bit $b_i$. Según el valor de $b_i$, el simulador escogerá una de las $n!$ permutaciones posibles de $G$ para ocultar el grafo en cajas negras, o bien uno de los $n!$ posibles $n$-ciclos, forme o no un ciclo hamiltoniano en $G$.

Ahora bien, suponíamos que las cajas negras eran en realidad la aplicación de un esquema de compromiso con vinculación incondicional, para proteger a V frente a un P \textit{todopoderoso} que pudiese cambiar los valores comprometidos. Vimos en la sección anterior que al tener vinculación incondicional, sólo podemos aspirar a secreto computacional, en nuestro modelo de comunicación donde P y V ven todo lo que se les envía. Esto significa que la única manera de diferenciar los ensambles anteriores es rompiendo el secreto del esquema de compromiso, y suponemos que no existe ningún algoritmo probabilístico polinomial que pueda hacerlo.

Tenemos por tanto que los ensambles son computacionalmente indistinguibles, y la prueba interactiva es de conocimiento cero computacional.



\subsection{Prueba de conocimiento cero para la 3-coloración de un grafo}

Otra prueba interactiva de conocimiento cero computacional es la de demostrar que un grafo $G$ posee una 3-coloración de sus nodos:


\begin{tabular}{|ll}
	\textit{Nombre:} & Problema G3C. \\
	\textit{Parámetros:} & Un grafo $G=(V,E)$. \\
	\textit{Pregunta:} & ¿Existe una función $\phi : V \to \{1,2,3\}$ tal que \\ & $\forall (u,v)\in E$, se cumple $\phi(u)\neq \phi(v)$? \\
\end{tabular}
\\

\hfil

Como el problema G3C es \textbf{NP}-completo, y como todos los problemas \textbf{NPC} son computacionalmente equivalente, en el sentido de que todos se pueden reducir polinomialmente a otro problema \textbf{NPC}, tenemos que todo problema en \textbf{NPC} tiene una prueba de conocimiento cero computacional.


\hfil

Blum presenta en \citep{blum} una prueba de conocimiento cero que sigue las líneas de la prueba del ciclo hamiltoniano, utilizando un bit como reto para desvelar el grafo $G$ o una prueba de que se ocultó una 3-coloración. Sin embargo, aquí presentamos una variación de la prueba que creemos es más sencilla de entender. 

La idea de esta prueba es que en cada iteración, P elige una permutación aleatoria de la 3-coloración, $\pi \in Sym(\{1,2,3\})$, y oculta cada vértice coloreado en una caja negra. El \textit{testigo} que enviará a V consistirá en ocultar toda la 3-coloración del grafo en $n$ cajas negras cuyos índices corresponden a los vértices del grafo. V elegirá como \textit{reto} una arista aleatoria. Como \textit{respuesta}, P enviará la coloración permutada de esa arista, que deberá tener colores distintos en cada extremo, y las claves de cifrado de cada una, de modo que V podrá comprobar si corresponden al \textit{testigo} enviado:

\hfil

\rule{\textwidth}{1pt}
\begin{algorithm}[Prueba interactiva para G3C]
	
	\hfil
	
	\textit{Datos comunes}: Una instancia $G=(V,E)$ del Problema G3C. $(\mid V \mid = n, \mid E \mid=m)$ es el tamaño del problema.
	
	\textit{Protocolo}: 
	
	P encuentra una 3-coloración $\phi$ de $G$.
	
	Sea $t(n)$ un polinomio en $n$. P y V repiten $t(n)\mid E \mid$ veces los siguientes pasos.
	
	\begin{enumerate}
		
		\item P selecciona al azar una permutación $\pi \in_R Sym(\{1,2,3\})$. Oculta en $n$ cajas negras la coloración: la caja $C_j$ ocultará el valor $\pi(\phi(v_j))$ del color permutado del vértice $v_j$.
		
		\item P $\rightarrow$ V :\quad $n$ cajas negras: $C_1, C_2, \dots C_n$.
		
		\item V $\rightarrow$ P :\quad $(u,v) \in_R E$, una arista aleatoria de $G$.
		
		\item P $\rightarrow$ V :\quad las claves $k_u$, $k_v$ que abren las cajas $C_u$, $C_v$.
		
		\item V abre las cajas y comprueba que $\pi(\phi(u)) \neq \pi(\phi(v))$.
		
		Si la comprobación falla, V termina en rechazo. En caso contrario, vuelve al paso 1.
		
		
	\end{enumerate}
	
	Tras $t(n)$ rondas, V termina y acepta la instancia como $Verdadera$, $G$ posee una 3-coloración.
	\label{G3Cinteractive:alg}
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil


La completitud es inmediata, pues si existe 3-coloración, un P ilimatado computacionalmente la podrá calcular, y podrá dar para $(u,v)$ colores distintos en cada ronda.

Si P$^*$ no conoce la 3-coloración, al menos hay una arista a la que P no puede dar colores distintos a sus vértices, y hay una probabilidad de $\frac{1}{\mid E \mid}$ de que V le rechace, es decir, una probabilidad $1-\frac{1}{\mid E \mid}$ de que P$^*$ triunfe. Tras $t(n)\mid E \mid$ rondas, P$^*$ sólo engañaría a V con una probabilidad $(1-\frac{1}{\mid E \mid})^{t(n)\mid E \mid} \approx e^{-t(n)}$, por lo que la prueba es robusta.

\hfil

La propiedad de conocimiento cero se prueba con un simulador que funciona como los anteriores, primero se elige el \textit{reto} (arista) y la \textit{respuesta} (dos colores), se calcula el \textit{testigo} respecto de ambos y se comprueba si V hubiera elegido dicho \textit{reto} a partir de un algoritmo probabilístico polinomial $F$:


\hfil 

\rule{\textwidth}{1pt}

\textbf{Simulador para el problema G3C} $S_{V^*}(G=(V,E), h)$.

\hfil

\textit{Datos}: \quad $G$, una instancia $Verdadera$ del problema G3C; $h$, transcripciones de ejecuciones previas del protocolo; $v_{i-1}$, transcripción de la interacción actual ($i-1$ rondas).

\textit{Ejecución}: Repetir para $i+1 \leq t(n)$:

\begin{enumerate}
	\item Elegir $e=(u,v)\in_R E$ una arista, y sus colores $(a,b)\in_R \{ (\alpha,\beta) \mid \alpha \neq \beta ;\ \alpha,\beta \in \{1,2,3\}  \}$ de manera aleatoria.
	
	\item Generar las cajas negras $C_j$ para $j=1,\dots n$ del siguiente modo:
	\[
			C_j \, oculta \, \begin{cases}
				a & si\ v_j=u,\\
				b & si\ v_j=v,\\
				0 & en\ otro\ caso.\\
			\end{cases}
	\] donde $v_j$ es un vértice de $G$.
	
	
	\item \textbf{Si} $e = F(G,h,v_{i-1},C_1, \dots, C_{n})$, \textbf{entonces} añadir la tupla \\ 
	$(C_1, \dots, C_{n},e=(u,v),k_u,k_v)$ a la transcripción, donde $K_{i+1}$ es el conjunto de claves para abrir las cajas, según el valor $b_{i+1}$. \\
	\textbf{Si no}, volver al paso 1.
	
	\item $i = i+1$
	
\end{enumerate}

\rule{\textwidth}{1pt}

\hfill




Durante una ronda del simulador tenemos una probabilidad de $\frac{1}{\mid E \mid}$ de que la arista escogida en el primer paso coincida con la que el algoritmo $F$ elegiría, de modo que el número esperado de rondas para generar las $t(n)$ rondas es polinomial.

Veamos ahora los ensambles de la Vista y la Simulación.
\begin{center}
	$Vista_{P,V^*}(G,h) = (G,h,C_1,E_1,K_1,\dots , C_{t(n)}, E_{t(n)}, K_{t(n)})$,
\end{center}
y 
\begin{center}
	$S_{V^*}(G,h) = (G,h,C_1',E_1',K_1',\dots , C_{t(n)}', E_{t(n)}', K_{t(n)}')$.
\end{center}

Donde la v.a. $C_i$ representa el conjunto de $n$ cajas negras que oculta la permutación de la coloración, la v.a. $E_i$ representa la arista $(u,v)$ elegida como reto por V en la ronda $i$, y la v.a. $K_i$ representa el par de llaves $(k_u,k_v)$ enviado como respuesta.

Por inducción sobre $i$, cuando $i=0$, los ensambles de la Vista y Simulador son idénticos, $(G,h)$. Suponemos cierto para $i-1$, en la $i$-ésima iteración tendremos:


En la Vista y el Simulador, las variables aleatorias $C_i$ y $C_i'$ corresponden a $n$ cajas negras, que cumplen un esquema de compromiso con vinculación incondicional y secreto computacional, de modo que a partir de estas $n$ cajas negras suponemos que no existe ningún algoritmo probabilístico en tiempo polinomial que las distinga de cualquier otra caja negra. Por tanto, la probabilidad de que aparezcan unas cajas negras u otras en la Vista y Simulador es computacionalmente indistinguible e independiente de las otras variables.

Respecto a las v.a. $E_i$ y $E_i'$, ambas dependen de la probabilidad de elegir un nodo de $F$, que podemos supones es $p_F$, idéntica para ambas.

En la apertura de las cajas negras con las claves de $K_i$ y $K_i'$ se desvelan dos colores distintos aleatorios, en la Vista porque la 3-coloración implica que ambos son distintos y después se le aplica una permutación aleatoria de entre las $3!$ posibles, por lo que dos colores distintos tienen una probabilidad uniforme de ser revelados, y por tanto, la misma probabilidad que la elección de colores aleatoria del Simulador.

Tal como ocurría en la prueba del grafo hamiltoniano, la condición de conocimiento cero computacional proviene de utilizar un esquema de compromiso con vinculación incondicional, y secreto computacional. 


\hfil


\hfil


\hfil

TODO: ¿párrafo de cierre del capítulo de ZKP, y paso a aplicaciones?
