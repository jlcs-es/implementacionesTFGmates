%\part{Pruebas de Conocimiento Cero}

%************************************************
\chapter{Pruebas de Conocimiento Cero}\label{ch:zkp} 
%************************************************

% REF
% Fundamentals pieprzyk2013fundamentals
% https://es.wikipedia.org/wiki/Prueba_de_conocimiento_cero 
% https://en.wikipedia.org/wiki/Interactive_proof_system
% How to Prove a Theorem So No One Else Can Claim It, Manuel Blum
% rosen2007discrete
% damgardcommitment
% blum



% Para la estadística referenciar:
% JL Gomez Pardo Introduction to cryptography with Mapple pardo2012introduction
% Elementos probabilidad Zoroa
%
% Fundamentals
% https://en.wikipedia.org/wiki/Computational_indistinguishability

Las pruebas de conocimiento cero, con siglas ZKP\index{ZKP} del inglés \textit{Zero-Knowledge Proofs}, permiten demostrar la veracidad de una declaración, sin revelar nada más de ella. En las ZKP intervienen dos partes, el \textit{Prover} y el \textit{Verifier}, o Probador y Verificador. El Probador asegura que una declaración es cierta, y el Verificador quiere convencerse de ello a través de una interacción con el Probador, de modo que al final de la misma, o bien acaba convencido de que la declaración es cierta, o bien descubre, con una alta probabilidad, que el Probador mentía.

Las pruebas de conocimiento cero surgen a partir de los sistemas de pruebas interactivas, que forman una parte importante de la teoría de complejidad computacional, a las que añadiendo la propiedad de \textit{conocimiento cero} obtenemos el subconjunto de sistemas interactivos que conforman las pruebas de conocimiento cero.

Las referencias utilizadas para este capítulo se pueden encontrar en \citep{pieprzyk2013fundamentals, rosen2007discrete, blum, damgardcommitment, Pardo, menezes1996handbook, stinson2005cryptography}.


\section{Sistemas de Pruebas Interactivas}

Un \textit{sistema de prueba interactivo} es un concepto perteneciente a la teoría computacional, que modela el intercambio de un número finito de mensajes entre dos partes, el probador P\index{P (probador)}\index{Probador} y el verificador V\index{V (verificador)}\index{Verificador}, con el objetivo de que P demuestre a V que una instancia de un cierto problema de decisión es $Verdadera$. V es una máquina con una capacidad de cómputo limitada, a lo sumo probabilístico de tiempo de polinomial. P es computacionalmente \textit{todopoderoso}. Al final del intercambio de mensajes, o bien V acepta que la instancia es $Verdadera$, o bien la rechaza por ser $Falsa$.

\begin{definition}\index{Prueba Interactiva}\index{Completo}\index{Robusto}

	
	Se dice que un problema de decisión $Q$, no necesariamente en \textbf{NP},  tiene un \textit{sistema de prueba interactivo} si tiene un protocolo de interacción polinomialmente acotado en número de mensajes que cumple:
	
	\begin{itemize}
		\item \textit{Completitud} Para toda instancia $q$ $Verdadera$, del problema $Q$, V acepta $q$ como $Verdadera$.
		\item \textit{Robustez} Para cada instancia $q$ $Falsa$, V rechaza la prueba de $q$ con una probabilidad no menor que $\epsilon = 1-n^{-c}$, para cualquier constante $c>0$ y donde $n$ es el tamaño de la instancia.
	\end{itemize}

\end{definition}

En resumen, si la instancia del problema $Q$ que P quiere demostrar es $Verdadera$, el protocolo siempre funciona, no hay falsos negativos, pero si la instancia es $Falsa$, hay una pequeña probabilidad de que $V$ la acepte como $Verdadera$, pueden haber falsos positivos una probabilidad casi despreciable.


Un P o un V que no siguen el protocolo e intentan romper estas propiedades, los llamaremos un P$^*$ o V$^*$ \textit{tramposos}.


\begin{definition}\index{IP}
	Denominamos clase de problemas \textbf{IP} (Interactivos en tiempo Polinomial) al conjunto de problemas de decisión para los que existe un sistema de prueba interactivo.
\end{definition}

\begin{proposition}
	\textbf{NP} $\subset$ \textbf{IP}.
\end{proposition}

\begin{proof}
	Sea $Q$ un problema \textbf{NP}. Definimos el siguiente protocolo:

	\begin{enumerate}
		\item  P resuelve la instancia del problema gracias a su capacidad de cómputo ilimitada y genera el certificado para V, que existe para cualquier instancia $Verdadera$ por $Q\in$ \textbf{NP} (\ref{def:NP}).
		\item  V recibe y puede verificar el certificado en tiempo polinomial. Si es válido, V acepta como $Verdadera$ la instancia. Si no, rechaza la prueba.
	\end{enumerate}

	El protocolo es completo y robusto, con probabilidad nula de falso positivo, pues si la instancia es $Falsa$, ningún P puede generar un certificado que no existe.

\end{proof}



\subsection{Prueba Interactiva para el Problema QR}

Vamos a ver una prueba interactiva para demostrar el problema QR (\autoref{problemaQR}), donde hemos de determinar si un entero $x$ con Símbolo de Jacobi 1 respecto a $n$, $x \in \mathbb{Z}^Q_n$, es un residuo cuadrático, $x \in \mathbb{Z}^{Q+}_n$.

\hfil

\rule{\textwidth}{1pt}
\begin{algorithm}[Prueba interactiva para QR]
	
	\hfil
	
	\textit{Datos comunes}: Una instancia ($x$, $N$) del Problema QR. $n$ es el tamaño de la instancia.
	
	\textit{Protocolo}: Sea $t(n)$ un polinomio en $n$. P y V repiten $t(n)$ veces los siguientes pasos.
	
	\begin{enumerate}
		
		\item P $\rightarrow$ V :\quad $u \in_R \mathbb{Z}^{Q+}_N$ \quad (P elige aleatoriamente $u$ en $\mathbb{Z}^{Q+}_N$).
		
		\item V $\rightarrow$ P :\quad $b \in_R \{0,\,1\}$.
		
		\item P $\rightarrow$ V :\; $w$,\; una raíz cuadrada módulo $N$ aleatoria, de $u$ si $b=0$, o bien de $x\cdot u$ si $b=1$.
		
		\item V comprueba si:
		\[
			w^2 \overset{?}{\equiv}
			\begin{cases}
				u\, mod\, N, & si\ b = 0\\
				xu\, mod\, N, & si\ b = 1.\\
			\end{cases}
		\]
		
		Si la comparación falla, V termina en rechazo. En caso contrario, vuelve al paso 1.
		
		
	\end{enumerate}

	Tras $t(n)$ rondas, V termina y acepta la instancia como $Verdadera$, $x$ es un residuo cuadrático módulo $N$.
	
	\label{QRinteractive:alg}
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil


\begin{theorem}
	El problema QR tiene un sistema de prueba interactiva.
	\label{theo:QRint}
\end{theorem}

\begin{proof}
	
	El protocolo \ref{QRinteractive:alg} se ejecuta $t(n)$ veces, un número de iteraciones polinomialmente asociado al tamaño $n$ de la entrada, por lo que hay un número finito de mensajes que V, computacionalmente limitado, puede llevar a cabo. 
		
	Queda ver que el protocolo anterior es completo y robusto.
	
	La prueba es \textit{completa}, pues para cualquier instancia $Verdadera$ de QR, $x \in \mathbb{Z}^{Q+}_N$, V acepta la prueba de P. En cada iteración, como P es computacionalmente todopoderoso, puede calcular $w$, una raíz cuadrada módulo $N$ de $x$ o $xu$, según el valor de $b$, ambos en $\mathbb{Z}^{Q+}_N$.
	
	Para una instancia $Falsa$, $x \in \mathbb{Z}^{Q-}_N$, cuando V envíe $b=1$, si P sigue el protocolo $u$ será un residuo cuadrático, pero $x\cdot u$ es un no-residuo cuadrático módulo $N$, por lo que no podrá calcular $w$ por mucho poder computacional ilimitado que tenga. Un P tramposo podría intentar engañar a V en el caso $b = 1$ eligiendo $u$ tal que $xu$ es un residuo cuadrático, pero entonces $u$ es un no-residuo cuadrático y fallaría la prueba si $b=0$.
	
	Una vez P se compromete con un $u$, residuo cuadrático o no, la probabilidad de que V lo rechace en esa iteración es $1/2$, según elija $b=0$ ó $1$. Como el protocolo se ejecuta $t(n)$ veces, la probabilidad de que un P tramposo pueda engañara V en todos es de $2^{-t(n)}$. Vemos entonces que el protocolo cumple la propiedad de \textit{robustez}.
\end{proof}


\section{Pruebas de conocimiento cero}

Entre las pruebas interactivas existe un subconjunto que llamamos de \textit{conocimiento cero} si durante el protocolo no se puede inferir información de P, aparte de la veracidad de la instancia. En particular, aún tras realizar la prueba, y estar V convencido, éste no podría repetirla a otro verificador tomando el lugar de P.

\hfil

Antes de ver una definición más formal de una prueba de conocimiento cero, necesitamos algunas definiciones previas. Seguiremos en esta sección el guión de \citep{pieprzyk2013fundamentals} que nos pareció el más indicado.



\begin{definition}\index{Vista}
	Llamamos \textit{Vista} a la transcripción de los mensajes intercambiados entre P y V durante la ejecución de una prueba interactiva.
\end{definition}

% Notación de una Vista

Pensemos en un protocolo con 3 mensajes por iteración. En la $i$-ésima ronda, P envía a V el valor $A_i$ como \textit{compromiso}, V responde con el \textit{reto} aleatorio $B_i$, y P termina enviando la \textit{prueba} $C_i$. La tupla $(A_i,\,B_i,\,C_i)$ son variables aleatorias de los posibles valores que se pueden intercambiar en una iteración. La Vista de la prueba interactiva sería la secuencia de los $t(n)$ mensajes intercambiados entre P y V:
\[(A_1,\,B_1,\,C_1,\,A_2,\,B_2,\,C_2,\dots ,\,A_{t(n)},\,B_{t(n)},\,C_{t(n)})\]


Una Vista sólo es de interés para una instancia $Verdadera$, donde P realmente conoce si es $Verdadera$. Para una instancia cuya prueba falla, o bien es una instancia $Falsa$ o P no puede probarla, por ser tramposo.


\begin{definition}\index{Ensamble}
	Llamamos ensamble probabilístico (\textit{ensemble} en inglés) a una familia de variables aleatorias $\{X_i\}_{i\in I}$, con $I$ numerable.
\end{definition}

Podemos estudiar entonces una Vista como un ensamble probabilístico. Dos Vistas serán iguales cuando las distribuciones de sus variables aleatorias sean idénticas.


\hfil

Cuando tratamos con V$^*$, un verificador tramposo, éste podría no generar los retos $B_i$ anteriores de manera independiente, podría incluso utilizar información previa de otras Vistas para generar los $B_i$ en un intento de obtener información extra de P. A esta información previa la llamaremos $h$ (historial).

Para una instancia $q$ y un verificador cualquiera V$^*$, escribimos la Vista de una prueba interactiva como:
\[ Vista_{P,V^*}(q,h) = (q,\,h,\,A_1,\,B_1,\,C_1, \dots ,\,A_{t(n)},\,B_{t(n)},\,C_{t(n)}). \]
El verificador tramposo V$^*$ generará los retos $B_i$ con un algoritmo probabilístico de tiempo polinomial $F$ tal que
\[ B_i = F(q,\,h,\,A_1,\,B_1,\,C_1, \dots ,\,A_{i-1},\,B_{i-1},\,C_{i-1},\,A_i). \]
Para un verificador honesto, $F$ se puede considerar como un generador de números aleatorios que no utiliza ninguno de los parámetros de entrada.



\begin{definition}\index{Simulador}
	Un Simulador $S_{V^*}(q,h)$ es un algoritmo probabilístico de tiempo polinomial, que utiliza toda la información que V$^*$ tiene disponible (el historial $h$ y la función $F$), para generar una transcripción de una prueba interactiva, para una instancia $q$ del problema $Q$, sin necesidad de interactuar con P.
\end{definition}

Un Simulador se puede ver como un generador de ensambles probabilísticos, la Vista de una prueba. La diferencia es que una transcripción de la Vista se genera a partir de dos máquinas, P y V, a diferencia del Simulador, que se ejecuta en una única máquina.


\hfil

Podemos describir, por fin, la tercera propiedad de las pruebas de conocimiento cero, que acompaña a la \textit{completitud} y la \textit{robustez}.


%\subsection{Pruebas de conocimiento cero perfectas}

\begin{definition}[Propiedad de conocimiento cero]	\index{Conocimiento Cero}\index{Conocimiento Cero Perfecto}
	Un sistema de prueba interactiva (completo y robusto), para un problema de decisión $Q$, es de \textit{conocimiento cero} si el ensamble $Vista_{P,V}(q,h)$ es idéntico al ensamble generado por un Simulador $S_{V^*}(q,h)$, para cualquier instancia $Verdadera$ $q\in Q$ y cualquier historial $h$.
\end{definition}

A las pruebas de conocimiento cero que cumplen la definición anterior también se les llama de \textit{conocimiento cero perfectas}, y veremos en futuras secciones otras definiciones menos restrictivas.

%La existencia de un Simulador $S_{V^*}(q,h)$, cuyos ensambles son iguales que los de una Vista generada entre un P y V honestos, implica que de la Vista no se puede obtener ninguna información que V no tuviera ya antes, pues V podía obtener con el Simulador cuantas Vistas quisiera, con el conocimiento que ya tenía.


De manera informal, el hecho de existir un simulador de conversaciones entre P y V que es idéntico a las interacciones reales, y que puede ejecutar cualquier máquina limitada computacionalmente, significa que de las transcripciones reales podemos sacar la misma información que ejecutando nosotros el simulador, y por tanto no aprenderíamos nada nuevo de ellas.



\subsection{Prueba de conocimiento cero para el problema QR}

Ahora podemos volver al problema QR, que ya vimos en el \autoref{theo:QRint} y cuya prueba interactiva cumplía \textit{completitud} y \textit{robustez}.

\begin{theorem}
	La prueba interactiva (\ref{QRinteractive:alg}) del problema QR es de conocimiento cero.
\end{theorem}

\begin{proof}
	Sea $(x,N)$ una instancia $Verdadera$ del problema QR, $\exists y\in \mathbb{Z}_N$ tal que $y^2\equiv x \, mod \, N$. En la $i$-ésima ronda tenemos las siguientes variables aleatorias:
	
	\begin{enumerate}
		\item $U_i$, un residuo cuadrático aleatorio enviado por P en el primer mensaje, $u \in_R \mathbb{Z}^{Q+}_N$.
		
		\item $B_i$, un bit aleatorio generado por V, $b \in_R \{0,\,1\}$.
		
		\item $W_i$, una \textit{prueba} de P, $w \in_R \Omega_u$ o bien $w \in_R \Omega_{xu}$, según el valor de $B_i$, es decir, una raíz cuadrada aleatoria módulo $N$ de $u$ ó $xu$, donde $\Omega_u$ y $ \Omega_{xu}$ son el conjunto de raíces cuadradas módulo $N$ de $u$ y $xu$, respectivamente.
	\end{enumerate}
	
	
	La Vista de una prueba para un verificador V$^*$ cualquiera es:
	\[Vista_{P,V^*}(x,N,h) = (x,\,N,\,h,\,U_1,\,B_1,\,W_1, \dots ,\,U_{t(n)},\,B_{t(n)},\,W_{t(n)}).\]
	
	%Para simplificar la notación, escribiremos $V_i=(U_1,\,B_1,\,W_1, \dots ,\,U_i,\,B_i,\,W_i)$.
	
	Para un V honesto, todos los $B_i$ son variables aleatorias independientes, uniformes en $\{0,1\}$. Para un V tramposo, la función $F$, probabilística en tiempo polinomial, genera los valores $b_{i+1} = F(x,N,h,v_i,u_{i+1})$, cuando $V_i = v_i$. Unimos el estudio de ambos casos suponiendo, para un V honesto, $F$ como un generador de bits aleatorio, un lanzamiento de moneda.
	
	Ahora que tenemos toda la información accesible a V$^*$ podemos construir un Simulador:
	
	\hfil 
	
	\rule{\textwidth}{1pt}
	
	\textbf{Simulador para el problema QR} $S_{V^*}(x,N,h)$.
	
	\hfil
	
	\textit{Datos}: \quad $(x,N)$, una instancia $Verdadera$ del problema QR; \quad $h$, transcripciones de ejecuciones previas del protocolo; \quad $v_i$, transcripción de la interacción actual ($i$ rondas).
	
	\textit{Ejecución}: Repetir para $i+1 \leq t(n)$:
	
	\begin{enumerate}
		\item Elegir $b_{i+1} \in_R \{0,\,1\}$
		
		\item Elegir $w_{i+1} \in_R \mathbb{Z}^*_N$
		
		\item \textbf{Si} $b_{i+1} = 0$, \textbf{entonces} calcular \qquad $u_{i+1} \equiv w_{i+1}^2 \, mod \,  N$ \\
			  \textbf{Si no}, \qquad \qquad \qquad \qquad \qquad \qquad \: $u_{i+1} \equiv w_{i+1}^2 \cdot x^{-1} \, mod \,  N$
			  
		\item \textbf{Si} $b_{i+1} = F(x,N,h,v_i,u_{i+1})$, \textbf{entonces} añadir la tupla \\ $(u_{i+1},\,b_{i+1},\,w_{i+1})$ a la transcripción. \\
			  \textbf{Si no}, volver al paso 1.
		
		\item $i = i+1$
		
	\end{enumerate}
	
	\rule{\textwidth}{1pt}
	
	\hfill
	
	El Simulador se diferencia del protocolo \ref{QRinteractive:alg} en que, en vez de elegir primero un residuo cuadrático $u_{i+1}$, elige los valores $b_{i+1}$ y $w_{i+1}$ aleatoriamente, y a partir de ellos calcula $u_{i+1}$. Entonces, una vez tiene el $u_{i+1}$ necesario para la función $F$, calcula el bit que V$^*$ hubiera enviado en una interacción real, y comprueba si es el mismo bit $b_{i+1}$ elegido. Aquí es donde vemos que el Simulador es un algoritmo probabilístico en tiempo del tipo Las Vegas (si obtenemos la tupla $i+1$, será una tupla correcta). La probabilidad de que el bit $b_{i+1}$ sea igual que el obtenido de $F$ es de $1/2$. En promedio, el Simulador necesitará dos rondas por cada tupla $(u_{i+1},\,b_{i+1},\,w_{i+1},\,)$, por lo que el tiempo de ejecución esperado es polinomial. 
	
	
	\hfil
	
	Tenemos una prueba interactiva (\ref{QRinteractive:alg}) que genera las vistas:
	\[ Vista_{P,V^*}(x,N,h) = (x,N,h,U_1,B_1,W_1,\dots , U_{t(n)}, B_{t(n)}, W_{t(n)}), \]
	y un Simulador que genera las transcripciones:
	\[ S_{V^*}(x,N,h)= (x,N,h,U_1^`,B_1^`,W_1^`,\dots , U_{t(n)}^`, B_{t(n)}^`, W_{t(n)}^`).\]
	
	Para terminar la demostración, veamos por inducción en $i$ que son iguales, es decir, cumplen la propiedad de \textit{conocimiento cero}.
	
	Para el caso $i=0$ ambos ensambles son constantes, $(x,N,h)=(x,N,h)$, tenemos la misma instancia e historial.
	
	Suponemos cierto el caso $i-1$, es decir, el ensamble de la Vista:
	\[ Vista_{P,V^*}(x,N,h) = (x,N,h,U_1,B_1,W_1,\dots , U_{i-1}, B_{i-1}, W_{i-1}), \]
	es igual al del Simulador:
	\[ S_{V^*}(x,N,h)= (x,N,h,U_1^`,B_1^`,W_1^`,\dots , U_{i-1}^`, B_{i-1}^`, W_{i-1}^`). \]
	

	Siguiendo el protocolo de la prueba interactiva, se generará la siguiente tupla de la Vista, $(U_i, B_i, W_i)$. La variable $U_i$ se elige al inicio aleatoriamente, por lo que es independiente. La v.a. $B_i$ se calcula con $F$, por lo que depende de $U_i$, $V_{i-1}$ y $h$. $W_i$ depende de ambos. La probabilidad de la tupla nos queda:
	\[
	P(U_i=u, B_i=b, W_i=w) = 
	\]
	\[ P(U_i=u)\cdot P(B_i=b \mid V_{i-1}=v, U_i=u,h) \cdot P(W_i=w \mid U_i=u, B_i=b) \]
	
	Sea $\alpha = \mid \mathbb{Z}^{Q+}_N \mid $, entonces $P(U_i=u) = \frac{1}{\alpha}$.
	
	Denotamos $ P(B_i=b \mid V_{i-1}=v, U_i=u,h)=p_b$, que dependerá de la $F$ utilizada.
	
	Por último, sea $\beta = \mid \Omega_u \mid = \mid \Omega_{xu} \mid $. Entonces:
	\[P(W_i=w \mid U_i=u, B_i=0) = 1/\beta,\ \forall w \in \Omega_u\]
	\[P(W_i=w \mid U_i=u, B_i=1) = 1/\beta,\ \forall w \in \Omega_{xu}\]
	
	En total nos queda, $P(U_i=u, B_i=b, W_i=w) = \frac{p_b}{\alpha \beta}$.
	
	
	Ahora veamos la tupla generada por el Simulador, $(U_i^`, B_i^`, W_i^`)$. La v.a. $U_i^`$ se calcula a partir de $B_i^`$ y $W_i^`$. La variable $B_i^`$ depende de $U_i^`$, $V_{i-1}$ y $h$ por $F$ en el paso 4. Y la v.a. $W_i^`$ se elige de manera uniforme en $\mathbb{Z}_N^*$.
	
	La probabilidad de la tupla es:
	\[P(U_i^`=u, B_i^`=b, W_i^`=w) = \]
	\[P(W_i^`=w)\cdot P(B_i^`=b \mid V_{i-1}=v, U_i^`=u,h) \cdot P(U_i^`=u \mid W_i^`=w, B_i^`=b)\]
	
	Sabemos que $\mid \mathbb{Z}^*_N \mid = \alpha \cdot \beta $, por lo que $P(W_i^`=w) = \frac{1}{\alpha \beta}$.
	
	Utilizando que $w\in \Omega_u \Leftrightarrow b=0$, $w\in \Omega_{xu} \Leftrightarrow b=1$ y que $W_i^`$ y $B_i^`$ son independientes, la probabilidad
	\begin{align*}
	P(U_i^`=u)  & = P(U_i^`=u, W_i^`\in \Omega_u \cup \Omega_{xu}, B_i^` \in \{0,1\}) = \\
				&= \sum_{w\in \Omega_u} P(U_i^`=u, W_i^`=w, B_i^` = 0) + \sum_{w\in \Omega_{xu}} P(U_i^`=u, W_i^`=w, B_i^` = 1) =  \\
				&= \sum_{w\in \Omega_u} P(W_i^`=w)P(B_i^` = 0) + \sum_{w\in \Omega_{xu}} P(W_i^`=w)P(B_i^` = 1) = \\
				&=\beta \cdot \frac{1}{\alpha \beta} \cdot (P(B_i^`=0) + P(B_i^`=1)) = \frac{1}{\alpha}
	\end{align*}
	indica que $U_i^`$ tiene la misma distribución que $U_i$, de modo que, al calcular $b_{i} = F(x,N,h,v_{i-1},u_{i})$, se tiene 
	$P(B_i^`=b \mid V_{i-1}=v, U_i^`=u,h) = p_b$, es decir, $B_i^`$ tiene la misma distribución que $B_i$.
	
	Por construcción, dados $w$ y $b$ en el simulador, $u$ tiene un único valor posible, $u\equiv w^2x^{-b}\,mod\,N$, por tanto, la probabilidad de que dada la tupla $(u, b, w)$, $U_i^`$ tenga el valor $u$ condicionado a que $ B_i^`=b$ y que $W_i^`=w$, es 1:
	\[P(U_i^`=u \mid W_i^`=w, B_i^`=b) = 1\]
	
	En total, tenemos que $P(U_i^`=u, B_i^`=b, W_i^`=w) = \frac{p_b}{\alpha \beta}$.
	
	
	Terminamos así la inducción en $i$ y los ensambles de la Vista y el Simulador son idénticos. Concluimos que la prueba interactiva \ref{QRinteractive:alg} del problema QR es perfecta de conocimiento cero.
	
\end{proof}



\subsection{Prueba de conocimiento cero para el problema de isomorfismo de grafos}


Otro problema de decisión del que podemos dar una prueba interactiva de conocimiento cero es el de determinar si dos grafos dados son isomorfos (\autoref{problemaGI}).


\begin{theorem}
	El problema GI tiene una prueba de conocimiento cero.
\end{theorem}


\begin{proof}
	
	\hfil
	
	Primero debemos dar un protocolo interactivo entre un P y un V que cumpla completitud y robustez. Después daremos un Simulador para demostrar la propiedad de conocimiento cero.
	
	\hfil

	\rule{\textwidth}{1pt}
	\begin{algorithm}[Prueba interactiva para GI]
		
		\hfil
		
		\textit{Datos comunes}: Una instancia ($G_0=(V_0,E_0)$, $G_1=(V_1,E_1)$) del Problema GI. $\mid V_0 \mid = \mid V_1 \mid = n$ es el tamaño de la instancia.
		
		\textit{Protocolo}: P calcula el isomorfismo $\tau$ entre $G_1$ y $G_0$, es decir, $\tau(G_1)=G_0$.
		
		Sea $t(n)$ un polinomio en $n$. P y V repiten $t(n)$ veces los siguientes pasos.
		
		\begin{enumerate}
			
			\item P $\rightarrow$ V :\quad $h = \pi (G_0)$, donde $\pi \in_R Sym(V_0)$.
			
			\item V $\rightarrow$ P :\quad $b \in_R \{0,\,1\}$.
			
			\item P $\rightarrow$ V :\; $\omega$,\; tal que
			\[
			\omega =
			\begin{cases}
			\pi  & si\ b = 0\\
			\pi \circ \tau  & si\ b = 1.\\
			\end{cases}
			\]
			
			\item V comprueba si:
			\[
			h \overset{?}{=}
			\begin{cases}
			\omega(G_0)  & si\ b = 0\\
			\omega(G_1)  & si\ b = 1,\\
			\end{cases}
			\]
			
			es decir, si $h$ es isomorfo a $G_b$ por $\omega$.
			
			Si la comparación falla, V termina en rechazo. En caso contrario, vuelve al paso 1.
			
			
		\end{enumerate}
		
		Tras $t(n)$ rondas, V termina y acepta la instancia como $Verdadera$, $G_0$ y $G_1$ son isomorfos.
		
		\label{GIinteractive:alg}
	\end{algorithm}
	\rule{\textwidth}{1pt}
	
	\hfil

	Sea $(G_0,G_1)$ una instancia $Verdadera$. Sea cual sea el reto $b$, P siempre puede devolver el isomorfismo $\omega$, pues $G_0$ y $G_1$ son ambos isomorfos a $h$. Tenemos que el protocolo es \textit{completo}.
	
	Si $(G_0,G_1)$ es $Falsa$, $G_0 \not\simeq G_1$, un P tramposo deberá adivinar el reto $b$ antes de calcular $h$, pues como éste debe ser un isomorfismo de $G_0$ ó $G_1$, no podrá serlo de ambos a la vez. La probabilidad de acertar el reto y mandar el isomorfismo correcto es de $1/2$ en cada ronda, por lo que la probabilidad de que un P tramposo engañe a V es de $2^{-t(n)}$. El protocolo es \textit{robusto}.
	
	\hfil
	
	Sea $(G_0, G_1)$ una instancia $Verdadera$ del problema GI. La Vista entre P y V es el ensamble
	\[ Vista_{P,V^*}(G_0, G_1, h) = (G_0, G_1, h,H_1,B_1,\Phi_1,\dots , H_{t(n)}, B_{t(n)}, \Phi_{t(n)}),\]

	donde la variable aleatoria $H_i$ representa el grafo isomorfo $h_i$ de la $i$-ésima ronda, la v.a. $B_i$ el reto $b_i$ de V a P, y $\Phi_i$ es el isomorfismo que envía P como respuesta al final de la ronda. El historial de anteriores transcripciones se representa con $h$.
	
	Como en el problema QR, V$^*$ podría utilizar un algoritmo probabilístico $F$, de tiempo polinomial, al calcular los retos $b_i$, para intentar obtener información de P. $F$ utilizará toda la información accesible a V$^*$ en el momento de enviar el reto.
	
	Construimos ahora el Simulador para la prueba interactiva:
	
	
	\hfil 
	
	\rule{\textwidth}{1pt}
	
	\textbf{Simulador para el problema GI} $S_{V^*}(G_0, G_1 ,h)$.
	
	\hfil
	
	\textit{Datos}: \quad $(G_0, G_1)$, una instancia $Verdadera$ del problema GI; \quad $h$, transcripciones de ejecuciones previas del protocolo; \quad $v_i$, transcripción de la interacción actual ($i$ rondas).
	
	\textit{Ejecución}: Repetir para $i+1 \leq t(n)$:
	
	\begin{enumerate}
		\item Elegir $b_{i+1} \in_R \{0,\,1\}$
		
		\item Elegir $\pi_{i+1} \in_R Sym(V_{b_{i+1}})$ y calcular $h_{i+1}=\pi_{i+1}(G_{b_{i+1}})$.
		
		\item \textbf{Si} $b_{i+1} = F(G_0,G_1,h,v_i,h_{i+1})$, \textbf{entonces} añadir la tupla \\ $(h_{i+1},\,b_{i+1},\,\pi_{i+1})$ a la transcripción. \\
		\textbf{Si no}, volver al paso 1.
		
		\item $i = i+1$
		
	\end{enumerate}
	
	\rule{\textwidth}{1pt}
	
	\hfill
	
	
	La probabilidad de que el bit $b_{i+1}$ elegido coincida con el de la función $F$ es $1/2$, por lo que en promedio se necesitarán dos rondas por tupla. El Simulador es un algoritmo probabilístico que se ejecuta en un tiempo estimado polinomial.
	
	\hfil
	
	Veamos ahora que el ensamble de la $Vista_{P,V^*}(G_0, G_1 ,h)$, es igual al del Simulador, $S_{V^*}(G_0, G_1 ,h)$. Procedemos por inducción sobre $i$, el número de rondas.
	
	Para $i=0$, ambos ensambles son constantes,
	\[Vista_{P,V^*}(G_0, G_1 ,h)=S_{V^*}(G_0, G_1 ,h)=(G_0, G_1, h),\]
	por lo que sus distribuciones de probabilidad son idénticas y los ensambles coinciden.
	
	Suponemos cierto para $i-1$ rondas, $P(Vista_{P,V^*}=v_{i-1}) = P(S_{V^*}=v_{i-1})$.
	
	Siguiendo el protocolo, se generarán las v.a. $(H_i, B_i, \Phi_i)$ para la $i$-ésima ronda. Utilizando el Teorema de la probabilidad compuesta, y observando la dependencia de las variables durante la ejecución del protocolo, calculamos:
	\begin{align*}
	& P(H_i=h, B_i=b, \Phi_i = \pi) = \\
	& P(\Phi_i = \pi) \cdot P(B_i = b \mid \Phi_i = \pi) \cdot P(H_i = h \mid \Phi_i = \pi, B_i=b)
	\end{align*}

	El isomorfismo $\pi$ se elige aleatoriamente entre todas las posibles permutaciones de $V_0$, como $\mid Sym(V_0) \mid = n!$, $P(\Phi_i = \pi) = \frac{1}{n!}$.
	
	La variable aleatoria $B_i$ se calcula con la función $F$, $B_i=F(h, V_i, H_i)$, por lo que asignamos la probabilidad $P(B_i = b \mid \Phi_i = \pi) = p_b$ dependiente de la $F$ que use V.

	Por último $P(H_i = h \mid \Phi_i = \pi, B_i=b) = 1$ por construcción del grafo $h$ por el isomorfismo $\pi$, independiente del valor de $B_i$.
	
	Nos queda en total que $P(H_i=h, B_i=b, \Phi_i = \pi) = \frac{p_b}{n!}$.
	
	\hfil
	
	Ahora consideramos la tupla de v.a.  $(H_i^`, B_i^`, \Phi_i^`)$ del Simulador.
	
	La variable $\Phi_i^`$ se elige aleatoriamente entre $Sym(V_0)$ o $Sym(V_1)$, ambos de mismo orden pues $\mid V_0 \mid = \mid V_1 \mid = n$, por lo que  $\mid Sym(V_0) \mid =$ $ \mid Sym(V_1) \mid =$ $ n!$, luego obtenemos $P(\Phi_i^` = \pi)=\frac{1}{n!}$.
	
	Como en la Vista, el Simulador utiliza $F$ para calcular el valor $b$ de $B_i^`$, así que $P(B_i^` = b \mid \Phi_i^` = \pi) = p_b$.
	
	Finalmente, $h$ viene determinado por $\pi$, de modo que $P(H_i^` = h \mid \Phi_i^` = \pi, B_i^`=b) = 1$.
	
	La probabilidad del Simulador nos queda $P(H_i^`=h, B_i^`=b, \Phi_i^` = \pi) = \frac{p_b}{n!}$, igual que la del ensamble de la Vista.
	
	\hfil
	
	
	Concluimos que se cumple la propiedad de \textit{conocimiento cero} y el problema GI tiene una prueba interactiva de conocimiento cero perfecta.
	
	
\end{proof}







\subsection{Prueba de conocimiento cero para el problema del logaritmo discreto}\label{perfectDL}


La última prueba de conocimiento cero perfecta que veremos será la del problema del logaritmo discreto (\autoref{problemaDL}) en su primera versión, el grupo es $G=\left\langle g \right\rangle $ de orden primo $q$, donde P debe probar que conoce la potencia $s$ que genera un cierto valor $y=g^s$. 


\begin{theorem}
	El problema DL tiene una prueba de conocimiento cero.
\end{theorem}


\begin{proof}
	
	\hfil
	
	Primero veremos un protocolo interactivo entre P y V para probar el conocimiento de $s$, y entonces comprobaremos las tres propiedades necesarias, completitud, robustez y conocimiento cero.
	
	\hfil
	
	\rule{\textwidth}{1pt}
	\begin{algorithm}[Prueba interactiva para DL]
		
		\hfil
		
		\textit{Datos comunes}: Una instancia ($G$, $q$, $g$, $y$) del Problema DL. $n=ord(g)=q$ es el tamaño del problema.
		
		\textit{Protocolo}: Sea $t(n)$ un polinomio en $n$. P y V repiten $t(n)$ veces los siguientes pasos.
		
		\begin{enumerate}
			
			\item P elige aleatoriamente $u \in_R \mathbb{Z}_q^*$.
			
			\item P $\rightarrow$ V :\quad $a = g^u$.
			
			\item V $\rightarrow$ P :\quad $b \in_R \{0,\,1\}$.
			
			\item P $\rightarrow$ V :\quad $w = (u + sb)\, mod \, q$.
			
			\item V comprueba si:
			\[
			g^w \overset{?}{=}
			\begin{cases}
			a  & si\ b = 0\\
			a\cdot y  & si\ b = 1.\\
			\end{cases}
			\]
			
			Si la comparación falla, V termina en rechazo. En caso contrario, vuelve al paso 1.
			
			
		\end{enumerate}
		
		Tras $t(n)$ rondas, V termina y acepta la instancia como $Verdadera$, P conoce el logaritmo discreto de $y \in G=\langle g \rangle $.
		\label{DLinteractive:alg}
	\end{algorithm}
	\rule{\textwidth}{1pt}
	
	\hfil
	
	
	Nótese que por el propio enunciado del problema, P no ha necesitado de su potencia ilimitada de cálculo.
	
	\hfil
	
	El protocolo es \textit{completo}, pues si P conoce $s$, siempre puede calcular un $w$ que pase la comprobación de V en el paso 5.
	
	\hfil
	
	Es también \textit{robusto}, pues suponiendo un grupo $G$ donde un P tramposo, una máquina limitada a cálculos en tiempo polinomial, no puede calcular fácilmente el secreto $s$, este P tramposo deberá intentar adivinar el reto $b$.
	
	Si P$^*$ supone que el reto $b=0$, seguirá el protocolo, mandando $w=u$, pero fallaría si V manda $b=1$, al no poder calcular el $s$.
	
	Si P$^*$ quiere superar un reto $b=1$, puede elegir $u$ como en el paso 1, enviar $a=g^u \cdot y-1$, y contestar al reto con $w=u$. Si se equivoca y V envía $b=0$, necesitaría $s$ para poder enviar el $w$ correcto y fallaría la prueba.
	
	La probabilidad de acertar el reto $b$ es de $1/2$, de modo que la probabilidad de pasar la prueba interactiva con una instancia $Falsa$ es de $2^{-t(n)}$. Se cumple la propiedad de \textit{robustez}.
	
	
	\hfil
	
	Nos queda comprobar la propiedad de \textit{conocimiento cero}.
	
	Como en casos anteriores, suponemos un algoritmo probabilístico polinomial $F$ que utiliza V$^*$ para enviar los retos. Si V fuera honesto, $F$ es un generador de números aleatorios con una distribución uniforme.
	
	
	
	\hfil 
			
	\rule{\textwidth}{1pt}
	
	\textbf{Simulador para el problema DL} $S_{V^*}(G, q, g, y, h)$.
	
	\hfil
	
	\textit{Datos}: \quad $(G, q, g, y)$, una instancia $Verdadera$ del problema DL; \quad $h$, transcripciones de ejecuciones previas del protocolo; \quad $v_i$, transcripción de la interacción actual ($i$ rondas).
	
	\textit{Ejecución}: Repetir para $i+1 \leq t(n)$:
	
	\begin{enumerate}
		\item Elegir $b_{i+1} \in_R \{0,\,1\}$
		
		\item Elegir $w_{i+1} \in_R \mathbb{Z}_q^*$.
		
		\item \textbf{Si} $b_{i+1} = 0$, \textbf{entonces} calcular \qquad $a_{i+1} = g^w$ \\
		\textbf{Si no}, \qquad \qquad \qquad \qquad \qquad \qquad \quad $a_{i+1} = g^w y^{-1} = g^{w-s}$
		
		\item \textbf{Si} $b_{i+1} = F(G, q, g, y,h,v_i,a_{i+1})$, \textbf{entonces} añadir la tupla \\ $(a_{i+1},\,b_{i+1},\,w_{i+1})$ a la transcripción. \\
		\textbf{Si no}, volver al paso 1.
		
		\item $i = i+1$
		
	\end{enumerate}
	
	\rule{\textwidth}{1pt}
	
	\hfill
	
	Por la elección aleatoria de $b_{i+1}$ y $w_{i+1}$ el Simulador es un algoritmo probabilístico, y el tiempo de ejecución estimado es de dos iteraciones por ronda simulada, pues la probabilidad de que el $b_{i+1}$ elegido coincida con el indicado por $F$ es de $1/2$.
	
	
	\hfil
	
	
	Por inducción sobre $i$, el número de rondas realizadas, veamos que los ensambles $Vista_{P,V^*}$ y $S_{V^*}$ son iguales:
	\begin{align*}
		Vista_{P,V^*} =& (G,q,g,y,h,A_1,B_1,W_1, \dots , A_i,B_i,W_i) \\
		S_{V^*} =& (G,q,g,y,h,A_1^`,B_1^`,W_1^`, \dots , A_i^`,B_i^`,W_i^`),
	\end{align*}
	donde las v.a. $A_i$, $A_i^`$ representan el testigo $a_i$ de la $i$-ésima ronda, las v.a. $B_i$, $B_i^`$ el bit del reto, y $W_i$, $W_i^`$ la respuesta de P.
	
	\hfil
	
	Para $i=0$, los ensambles $Vista_{P,V^*} = (G,q,g,y,h)$ y $S_{V^*} = (G,q,g,y,h)$ son constantes e iguales.
	
	Suponemos cierto para $i-1$.
	
	La tupla de las v.a. para la ronda $i$ en la Vista es: $(A_i,B_i,W_i)$.
	
	Su probabilidad se calcula como:
	\begin{align*}
	& P(A_i=a, B_i=b, W_i = w) = \\
	& P(A_i = a) \cdot P(B_i = b \mid A_i = a) \cdot P(W_i = w \mid A_i = a, B_i=b)
	\end{align*}
	% 1/q-1 * p_b * 1
	
	Por construcción, $a$ depende de la elección de $u$, elegido de entre $q-1$ posibles valores, $P(A_i = a) = 1/(q-1)$.
	
	V$^*$ utiliza $F(G,q,g,y,a)$ para la elección de $b$, así que podemos escribir $P(B_i = b \mid A_i = a) = p_b$, dependiente de la $F$ empleada.
	
	Finalmente, en el protocolo $w$ depende para su cálculo de $a$ y $b$, así que la probabilidad dependiente de ambos valores dados, es 1.
	
	Concluimos que $P(A_i=a, B_i=b, W_i = w) = \dfrac{p_b}{q-1}$.
	
	
	Observando el orden en que se calculan los valores en el Simulador, la probabilidad de la $i$-ésima tupla del Simulador es:
	\begin{align*}
	& P(A_i^`=a, B_i^`=b, W_i^` = w) = \\
	& P(W_i^` = w) \cdot P(B_i^` = b \mid W_i^` = w) \cdot P(A_i^` = a \mid W_i^` = w, B_i^`=b)
	\end{align*}
	% 1/q * p_b * 1
	
	El valor de $w_{i+1}$ se elige en $\mathbb{Z}_q^*$ independientemente de los demás. Así que $P(W_i^` = w) =  1/(q-1)$.
	
	Como antes, la elección del bit depende de $F$. $  P(B_i^` = b \mid W_i^` = w) = p_b $.
	
	Y siguiendo los pasos del Simulador, el valor de $a$ queda unívocamente determinado dados $w$ y $b$, así que $P(A_i^` = a \mid W_i^` = w, B_i^`=b) = 1$.
	
	Nos queda $ P(A_i^`=a, B_i^`=b, W_i^` = w) = \dfrac{p_b}{q-1}$, igual que la Vista, de modo que los ensambles son idénticos y queda demostrado el teorema.
	
\end{proof}


\hfil

\paragraph{Otros tipos de pruebas de conocimiento cero}

La propiedad de \textit{conocimiento cero perfecta} exige que exista un Simulador probabilístico de tiempo polinomial, cuyo ensamble sea idéntico al del protocolo. Una variación de la propiedad de conocimiento cero admite que los ensambles sean asintóticamente iguales, y de este modo a las pruebas se les llama \textit{pruebas de conocimiento cero estadísticas}\index{Conocimiento Cero Estadístico}.

Al relajar la definición de conocimiento cero, ampliamos la cantidad de pruebas de conocimiento cero conocidas, y por eso se definen diferentes tipos de \textit{conocimiento cero}, con menos restricciones, que en la práctica pueden funcionar como las pruebas de conocimiento cero perfectas, e incluso en ocasiones ser más óptimos.



\hfil


\section{Pruebas de conocimiento cero de Verificador Honesto}\label{honestVer:sec}


% rosen2007discrete

En esta sección veremos un tipo de pruebas de conocimiento cero utilizadas en la práctica, que derivan de las ZKP perfectas al añadir una condición al Verificador: que siempre cumpla el protocolo indicado.

En las pruebas de conocimiento cero perfectas que hemos visto, los simuladores estudiados consideraban la existencia de un algoritmo $F$ que un Verificador tramposo, V$^*$, utilizaría para elegir los retos, en un intento de obtener más información de P. En este tipo de pruebas, V no dispondrá de $F$ para elegir los retos.


\begin{definition}[Propiedad de conocimiento cero con Verificador Honesto]\index{Conocimiento Cero Verificador Honesto}\index{Verificador Honesto}
	\hfil
	
	Un sistema de prueba interactiva (completo y robusto), para un problema de decisión $Q$, es \textit{perfecta de conocimiento cero con Verificador Honesto} si el ensamble $Vista_{P,V}(q,h)$ es idéntico al ensamble generado por un Simulador $S_{V}(q,h)$, donde el Verificador V sigue los pasos del protocolo, para cualquier instancia $Verdadera$ $q\in Q$ y cualquier historial $h$.
\end{definition}

\hfil

Veremos en este apartado una variación de la prueba de conocimiento cero perfecta basada en el problema del Logaritmo Discreto (\ref{problemaDL}), llamado \textit{Protocolo de Identificación de Schnorr}\index{Schnorr}. Para esta prueba seguiremos principalmente el texto de Stinson \citep[Section 9.4]{stinson2005cryptography}.

Primero hemos de definir unos parámetros comunes conocidos por P y V. Elegimos dos valores primos, $p$ y $q$ tal que $p\equiv 1 \, mod \, q$, es decir, $q\mid (p-1)$, y el problema del logaritmo discreto es difícil en el subgrupo de $\mathbb{Z}_p^*$ generado por $\alpha$ con orden $q$. Además debemos elegir un valor $t$ que definirá la robustez del protocolo. En resumen tenemos:

\begin{itemize}
	\item $p$ primo.
	\item $q$ primo divisor de $(p-1)$.
	\item $\alpha \in \mathbb{Z}_p^*$ de orden $q$.
	\item $t$ un \textit{parámetro de seguridad}, con la condición de que $2^t < q$. La robustez del protocolo, es decir, la probabilidad de que un P$^*$ tramposo engañe a V, será de $2^{-t}$.
\end{itemize}


El \textit{secreto} de P será el valor $a$, tal que $0\leq a \leq q-1$. La prueba consistirá en demostrar que P conoce dicho valor. P calcula entonces el valor público $v = \alpha ^{-a} \, mod \, p$. Éste valor se puede calcular como la inversa $\left( \alpha ^{a} \right) ^{-1} \, mod \, p$, o como $\alpha ^{q-a} \, mod \, p$.

Mostramos el protocolo de Schnorr:

\rule{\textwidth}{1pt}
\begin{algorithm}[Schnorr]\label{schnorr:algint}
	
	\hfil
	
	\textit{Datos comunes}: $p$, $q$, $\alpha$, $t$ y $v$.
	
	\textit{Datos de P}: $a$.
	
	\textit{Protocolo}: Realizar una vez:
	
	\begin{enumerate}
		
		\item P elige aleatoriamente $k \in_R \mathbb{Z}_q$.
		
		\item P $\rightarrow$ V :\quad $\gamma = \alpha^k \, mod \, p$ (el \textit{testigo}).
		
		\item V $\rightarrow$ P :\quad $r$ aleatorio, tal que $1\leq r\leq 2^t < q $ (el \textit{reto}).
		
		\item P $\rightarrow$ V :\quad $y = k + ar \, mod \, q$ (la \textit{respuesta}).
		
		\item V comprueba si $\gamma \overset{?}{\equiv} \alpha^y v^r \, mod \, p$
		
		Si la comparación falla, V termina en rechazo. En caso contrario, acepta la prueba.
		
		
	\end{enumerate}
	
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil

Este algoritmo en particular se diseñó con el objetivo de minimizar la cantidad de mensajes intercambiados manteniendo una robustez que lo hiciera seguro. Como veremos, una sola interacción nos dará una probabilidad de $2^{-t}$ de que un atacante consiga engañar al Verificador.


\begin{theorem}
	El protocolo de identificación de Schnorr \ref{schnorr:algint} es una prueba interactiva.
\end{theorem}

\begin{proof}
	Como sólo existe una ronda de 3 mensajes, el algoritmo es probabilístico de tiempo polinomial.
	
	
	Veamos ahora la \textit{completitud}. Veamos con las siguientes congruencias que que si P conoce $a$, siempre podrá responder correctamente al reto:
	\[
	\alpha^y v^r \equiv \alpha ^{k+ar} v^r \equiv \alpha^{k+ar} \alpha ^{-a r} \equiv \alpha ^k \equiv \gamma \, mod \, p
	\]
	
	Por tanto, un P y V honestos finalizarán el protocolo en aceptación siempre, la prueba es \textit{completa}.
	
	Finalizamos con el análisis de la \textit{robustez}. El \textit{parámetro de seguridad} $t$ define la dificultad de adivinar el reto de V. Si P$^*$ adivinara el valor $r$ aleatorio de V, podría superar la prueba eligiendo un valor $y$ aleatorio y calculando $\gamma = \alpha ^y v ^r \, mod \, p$, con lo que enviando primero el $y$ y respondiendo al reto con $\gamma$ pasaría la prueba. La probabilidad de adivinar correctamente un reto $1\leq r\leq 2^t$ elegido aleatoriamente es de $\frac{1}{2^t}$.
	
	
	Supongamos que P$^*$ puede adivinar el reto de V con una probabilidad mayor a $2^{-t}$, entonces P$^*$ conocería para un valor $\gamma$ de su elección, al menos dos respuestas posibles para dos retos distintos de V, es decir, si antes el P$^*$ tramposo podía precalcular un testigo y una respuesta para un reto de V, ahora puede calcular, para el mismo testigo (pues solo puede enviar uno antes de recibir el reto), P$^*$ conoce la respuesta de al menos dos retos.
	
	Sea $\gamma$ el testigo para el que P$^*$ conoce los valores $r_1$, $y_1$ y $r_2$, $y_2$, un par de posibles retos y respuestas válidas, que cumplen $\gamma \equiv \alpha^{y_1} v^{r_1} \equiv \alpha^{y_2} v^{r_2} \, mod \, p$. Se sigue que $\alpha^{y_1 - y_2} \equiv v ^{r_2 - r_1}  \, mod \, p$.
		
	Como la \textit{clave pública} se calculaba $v\equiv \alpha^{-a} \, mod \, p$, con $a$ el secreto de P, podemos sustituir: $\alpha^{y_1 - y_2} \equiv \alpha ^{-a(r_2 - r_1)}  \, mod \, p$. Y como $\alpha$ tiene orden $q$, podemos trabajar con los exponentes como $y_1 - y_2 \equiv a(r_1 - r_2) \, mod \, q$.
	
	Por la condición sobre los retos $1\leq r \leq 2^t < q$, sabemos que $0 < \mid r_2 - r_1 \mid < 2^t < q$, y como $q$ es primo, $mcd(r_2-r_1,q)=1$, de modo que existe el inverso $(r_1 - r_2)^{-1} \, mod \, q$, y el P$^*$ puede calcular el secreto $a$ como $a = (y_1-y_2)(r_1-r_2)^{-1}\, mod \, q$.
	
	A partir de este análisis, vemos que cualquiera que pueda superar la prueba frente a V con una probabilidad mayor a $2^{-t}$ puede calcular el secreto de P, y sería una instancia $Verdadera$ del problema.
	
	
	
\end{proof}





\hfil



Después de ver la \textit{completitud} y \textit{robustez} del protocolo, tenemos una prueba interactiva, pero nos falta comprobar la propiedad de \textit{conocimiento cero con verificador honesto}.

\begin{theorem}
	La prueba interactiva de Schnorr \ref{schnorr:algint} es de conocimiento cero con verificador honesto.
\end{theorem}

\begin{proof}


Una transcripción o vista del protocolo es simplemente el ensamble probabilístico con una tupla $Vista_{P,V} =(\Gamma, R, Y)$.

Calculamos la probabilidad $P(\Gamma=\gamma, R=r, Y=y) = P(\Gamma=\gamma)P(R=r\mid \Gamma =\gamma)P(Y=y\mid \Gamma=\gamma, R=r)$.


P calcula $\gamma$ a partir de un valor $k$ aleatorio entre $0$ y $q-1$, y elevando $\alpha$, de orden $q$, a dicho valor, de modo que la probabilidad de que $\Gamma$ tome el valor $\gamma$ es igual a la de elegir el $k$ que lo genera: $P(\Gamma=\gamma)=\frac{1}{q}$.

Bajo el supuesto de Verificador Honesto, $P(R=r\mid \Gamma =\gamma)=P(R=r)=\frac{1}{2^t}$, pues V seguirá el protocolo, eligiendo el reto uniformemente entre $1$ y $2^t$, sin usar la función $F$ de apartados previos.

Finalmente, $y=k+ar$ depende del $k$ que genera $\Gamma=\gamma$, del secreto $a$ de P y del reto $R=r$ de V. La probabilidad condicionada vale $P(Y=y \mid \Gamma =\gamma, R=r)=1$.

Tenemos que la probabilidad de obtener la Vista $(\gamma, r, y)$ es de $\frac{1}{q\cdot 2^{t}}$.

\hfil

Ahora definimos el Simulador de la prueba, con la restricción de Verificador Honesto:


\rule{\textwidth}{1pt}
\begin{algorithm}
	
	\hfil
	
	\textit{Datos}: $p$, $q$, $\alpha$, $t$ y $v$.
	
	\textit{Protocolo}: Realizar una vez:
	
	\begin{enumerate}
		
		\item Elegir $r$ aleatorio tal que $1\leq r \leq 2^t$.
		\item Elegir $y$ aleatorio tal que $0\leq y \leq q-1$.
		\item Calcular $\gamma = \alpha ^y v^r \, mod \, p$.		
		
	\end{enumerate}
	
\end{algorithm}
\rule{\textwidth}{1pt}


El ensamble del Simulador se puede escribir como el conjunto:
\[
S_{V} = (\Gamma, R, Y) = \{ (\gamma', r', y') : 1\leq r' \leq 2^t,\, 0\leq y'\leq q-1,\, \gamma' \equiv \alpha^y v^r \, mod \, p \}
\]

Como $\gamma'$ depende totalmente de $r'$ e $y'$, que se eligen independientemente entre sí, tenemos que $\mid S_V \mid = q\cdot 2^t$, es decir, $P(\Gamma'=\gamma', R'=r', Y'=y)=\frac{1}{q\cdot 2^t}$, la misma que la probabilidad de la Vista. 


Tenemos por tanto, que el protocolo de Schnorr es una Prueba de Conocimiento Cero con Verificador Honesto.

\end{proof}

\hfil

A día de hoy, para probar que Schnorr es de conocimiento cero perfecta, donde un Verificador utilizaría la función $F$ que elige los retos no uniformemente entre $1$ y $2^t$, no se conoce ningún simulador que sea probabilístico en tiempo polinomial, condición indispensable para probar que es perfecta.


%%%%%%%%
Aún así, Schnorr es utilizado ampliamente en la práctica, pues tampoco se conoce ningún ataque a partir de la elección de retos no aleatorios. Se puede demostrar que algunas variaciones del protocolo son pruebas de conocimiento cero perfectas, para ello hay que añadir ciertas condiciones, como reducir el espacio de retos, a cambio de incrementar las rondas para mantener el nivel de robustez. Con un bit por reto y $t$ rondas, en la sección anterior demostramos que el protocolo era una prueba de conocimiento cero perfecta, pero en la práctica es muy poco eficiente por la cantidad de mensajes intercambiados.
%%%%%%%%%





\section{Esquemas de compromiso}\label{bitcommitment}

En las pruebas de conocimiento cero vistas hasta ahora, el primer mensaje del Probador consistía en un \textit{compromiso} con el Verificador, al que llamamos \textit{testigo}, de modo que en la respuesta al reto no pudiera engañarle, con cierta probabilidad.


Antes de introducir el último tipo de Pruebas de Conocimiento Cero de este capítulo, las Computacionales, debemos estudiar la existencia y propiedades de los llamados esquemas de compromiso, una herramienta que nos permite dar para todo problema \textbf{NPC} una Prueba de Conociemiento Cero Computacional, como muestra Manuel Blum en \citetitle{blum} \citep{blum}. La bibliografía básica para esta sección se encuentra principalmente en \citep{pieprzyk2013fundamentals,damgardcommitment}.

Estos esquemas permiten esconder la estructura de una instancia $Verdadera$, donde P se compromete con su \textit{testigo} antes de conocer el \textit{reto} de V, de modo que V no puede obtener información de estos testigos. En la última \textit{respuesta} de P, se revelará una pequeña parte de la estructura de la instancia $Verdadera$, de la cual V no podrá aprender tampoco nada.


Empecemos definiendo un esquema de compromiso para un bit:


\begin{definition}\label{commit:def}\index{Esquema de compromiso}\index{Compromiso}\index{Vinculación}\index{Secreto}
	Un esquema de compromiso de un \textit{bit} es un par de funciones $(f,v)$ de tiempo polinomial. La función
	
	$
	f:\{0,1\}\, x\, \Upsilon \to \chi
	$
	\\transforma el bit $b\in \{0,1\}$ con una clave aleatoria $y\in \Upsilon$. El valor $x=f(b,y)$ lo llamaremos \textit{blob} o \textit{testigo} de $b$. La función de verificación
	
	$
	v:\chi \, x \, \Upsilon \to \{0,1,\bullet\}
	$
	\\abre el blob revelando el bit $b$, o indicando que no es un par (blob,clave) válido.
	
	El par $(f,v)$ debe cumplir la siguientes condiciones:
	\begin{enumerate}
		\item \textit{Vinculación}: Para todo blob $x=f(b,y)$, P no es capaz de encontrar un valor $y' \neq y$ tal que el blob se puede abrir con otro valor, es decir, $v(x,y) \neq v(x,y')$.
		
		\item \textit{Secreto}: Los ensambles $\{f(0,\Upsilon)\}$ y $\{f(1,\Upsilon)\}$ son indistinguibles.
	\end{enumerate}
	
\end{definition}

\hfil

Podemos clasificar los esquemas de compromiso de bit en dos tipos:

\begin{definition}[Vinculación incondicional]\index{Vinculación incondicional}
	Una máquina P con una capacidad computacional ilimitada (como en las pruebas interactivas) no puede cambiar el bit comprometido en el \textit{testigo} enviado.
\end{definition}

\begin{definition}[Secreto incondicional]\index{Secreto incondicional}
	Los ensambles $\{f(0,\Upsilon)\}$ y $\{f(1,\Upsilon)\}$ son idénticos. Es decir, dada una máquina V con capacidad computacional ilimitada, no es capaz de distinguir los ensambles con mayor probabilidad que eligiendo al azar el posible valor de $b$.
\end{definition}

\begin{proposition}
	En un entorno donde tenemos dos interlocutores, P y V, que ven todo lo que el otro les envía, no existe ningún esquema de compromiso con vinculación y secreto incondicionales a la vez.
\end{proposition}

\begin{proof}
	Supongamos que tenemos vinculación incondicional, P no puede encontrar un valor $y'$ que abra $x$ con un bit diferente. Entonces V podría distinguir a qué $b$ corresponde el testigo $x$ recibido, siendo un posible algoritmo probar todos los valores $y'\in \Upsilon$ hasta encontrar el que hace $ v(x,y') \neq \bullet$. Aunque una máquina convencional podría tardar demasiado tiempo, estamos suponiendo que V puede ser computacionalmente ilimitado para el caso de secreto incondicional, y por tanto, no podemos tener ambas propiedades incondicionales a la vez.
\end{proof}

Sin embargo, se puede conseguir una condición menos restrictiva, pero equivalentes en la práctica:

\begin{definition}[Vinculación computacional]\index{Vinculación computacional}
	No existe ningún algoritmo probabilístico en tiempo polinomial que permita encontrar un $y'$ tal que P puede cambiar el bit comprometido.
\end{definition}

\begin{definition}[Secreto computacional]\index{Secreto computacional}
	No existe ningún algoritmo probabilístico en tiempo polinomial que permita distinguir los ensambles probabilísticos $\{f(0,\Upsilon)\}$ y $\{f(1,\Upsilon)\}$. Se dice que los ensambles son \textit{indistinguibles polinomialmente}.
\end{definition}


Para conseguir vinculación y secreto incondicionales a la vez, han de utilizarse otras técnicas de comunicación, como canales con ruido o múltiples participantes \citep{damgardcommitment, crepeau1997efficient, ben1988completeness, chaum1988multiparty, crepeau1988achieving}.



\subsection{Esquemas de compromiso con secreto incondicional}

En este apartado vamos a mostrar ejemplos de esquemas de compromiso de bit que consiguen secreto incondicional y vinculación computacional, basándose en los mismos problemas vistos para las pruebas de conocimiento perfectas: residuos cuadráticos, logaritmo discreto e isomorfismo de grafos.

\hfil

El esquema basado en residuos cuadráticos lo inicia V, eligiendo el módulo $n=pq$ producto de dos primos, de modo que el problema QR módulo $n$ es impracticable para P. V además elige un $t\in_R \mathbb{Z}_n^*$ para calcular el residuo $s=t^2\,mod\,n$. El par $(s,n)$ se hace público para que P lo utilice. Utilizaremos como conjunto de \textit{claves} $\Upsilon = \mathbb{Z}_n^*$ y como conjunto de los posibles blobs o testigos $\chi = \mathbb{Z}_n^{Q+}$, los residuos cuadráticos.

El algoritmo de compromiso es como sigue:



\hfil

\rule{\textwidth}{1pt}
\begin{algorithm}[Compromiso de bit basado en residuos cuadráticos]\label{commitQRsec:alg}
	\hfil
	
	\textit{Ocultación}: P elige al azar $y\in \mathbb{Z}_n^*$ y oculta el bit $b$ como:
	\[x = f(b,y) = s^b y^2 \, mod \, n \]
	
	\textit{Apertura}: P envía a V el valor $y$. V calcula el bit $b$:
	\[ b = v(x,y) = 
	\begin{cases}
	0  & si\ x\equiv y^2 \, mod \, n  \\
	1 & si\ x\equiv s\cdot y^2 \, mod \, n\\
	\bullet & en\ otro\ caso.
	\end{cases}
	\]
	\label{bitcommitQR:alg}
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil


\begin{proposition}
	El algoritmo \ref{bitcommitQR:alg} es un esquema de compromiso de bit con vinculación computacional y secreto incondicional.
\end{proposition}

\begin{proof}
	La ocultación consiste en enviar como testigo un residuo cuadrático módulo $n$, y a la hora de desvelar el valor del bit, P debe desvelar una raíz cuadrada de $x$. Si P es una máquina limitada polinomialmente, al no conocer la factorización de $n$, no podrá calcular la raíz cuadrada de $x$. Si pudiera calcular dicha raíz, el ataque consistiría en seguir el protocolo para el bit $b=1$, de modo que conocemos el $y$ para abrirlo como $1$, y cuando P quiera cambiar el bit oculto a $0$, calculará la raíz cuadrada módulo $n$ de $s\cdot y^2$, de modo que V obtendrá en la \textit{apertura} $b=0$. Suponiendo que el problema de la factorización es intratable, tenemos \textbf{vinculación computacional}.
	
	%Por otro lado, si P elige de modo aleatorio $y\in \mathbb{Z}_n^*$, como los ensambles probabilísticos $\{f(0,\Upsilon)\}$ y $\{f(1,\Upsilon)\}$ son idénticos, tenemos \textbf{secreto incondicional}. Un V \textit{todopoderoso} computacionalmente no podría distinguirlos mejor que eligiendo un $y$ al azar, ni al calcular todas las raíces modulares del testigo $x$ recibido, pues o bien una de esas raíces es el $y$ escogido por P, o bien una de ellas corresponde al valor $t\cdot y \, mod \, n$, para el $y$ adecuado.
	
	Por otro lado, sea $\beta=\mid \Omega_x \mid$ con $\Omega_x$ el conjunto de raíces modulares de $x$, que un V \textit{todopoderoso} es capaz de calcular.
	Sea $r \in \Omega_x$ la raíz modular de $x$ usada por P en el protocolo, e $Y$ la variable aleatoria que representa la clave $y$. Si $b=0$ tenemos que $P(Y=y)=P(r=y)=1/\beta$, pues alguna de las raíces será igual a $y$. Si $b=1$, la raíz utilizada para generar $x$ será $r=t y\, mod\, n$, y como $t$ es un valor prefijado, $y$ está unívocamente determinada por $r$, entonces $P(Y=y)=P(r=ty)=1/\beta$. Por tanto, los ensambles probabilísticos $\{f(0,\Upsilon)\}$ y $\{f(1,\Upsilon)\}$ son idénticos, y tenemos \textbf{secreto incondicional}.
	
\end{proof}


\hfil


A continuación, presentamos otro esquema de compromiso basado en el logaritmo discreto, conocido como \textit{compromiso de Pedersen}\index{Pedersen}. Para llevarlo a cabo, P y V deben primero decidir un $p$ primo suficientemente grande y un generador $g\in \mathbb{Z}_p^*$ donde el problema del logaritmo discreto es \textit{difícil}. V además elige un valor aleatorio $s\in \mathbb{Z}_{p-1}$, de modo que no se conoce $log_g s$, y lo envía a P. Los conjuntos del esquema de compromiso son $\Upsilon = \mathbb{Z}_{p-1}$ para las \textit{claves} y $\chi= \mathbb{Z}_p^*$ para los blobs.





\hfil

\rule{\textwidth}{1pt}
\begin{algorithm}[Compromiso de bit basado en logaritmo discreto]
	\hfil
	
	\textit{Ocultación}: P elige al azar $y\in \Upsilon$ y oculta el bit $b$ como:
	\[x = f(b,y) = s^b g^y \, mod \, p \]
	
	\textit{Apertura}: P envía a V el valor $y$. V calcula el bit $b$:
	\[ b = v(x,y) = 
	\begin{cases}
	0  & si\ x\equiv g^y \, mod \, p  \\
	1 & si\ x\equiv s g^y \, mod \, p \\
	\bullet & en\ otro\ caso.
	\end{cases}
	\]
	\label{bitcommitDL:alg}
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil

\begin{proposition}
	El algoritmo \ref{bitcommitDL:alg} es un esquema de compromiso de bit con vinculación computacional y secreto incondicional.
\end{proposition}

\begin{proof}
	
	El ataque a este esquema de compromiso consistiría en calcular el logaritmo discreto de $s$ módulo $p$, llamémoslo $t$, tal que $g^t=s\,mod\,p$. Si P oculta $b=0$, enviará $x=g^y\,mod\,p$, y para poder abrir al valor $b=1$ puede enviar a V  $(y-t)$, de modo que V calculará $sg^{y-t}\equiv g^t g^{y-t} \equiv g^y \equiv x \, mod \, p$, obteniendo $b=1$. En el caso contrario, donde P oculta $b=1$, enviará $x=sg^y\,mod\, p$ a V como testigo, y para abrir el bit como $b=0$ basta con enviar $y+t$, tal que V calculará $g^{y+t}\equiv g^t g^y \equiv s g^y\, mod\, p$, creyendo entonces que $b=1$. Si P es computacionalmente limitado, no podrá resolver el problema del logaritmo discreto y obtenemos una \textbf{vinculación computacional}.
	
	Suponiendo un V computacionalmente ilimitado, éste podría calcular el logaritmo discreto de $x$ módulo $p$, llamémoslo $u$, tal que $x\equiv g^u\,mod\,p$, además del valor $t$ que genera $s$, $s\equiv g^t\,mod\,p$. Una vez conocidos $u$ y $t$, la probabilidad de que $y$ valga $u$ ó $(u-t)$, según sea $b=0$  $(x\equiv g^u \equiv g^y \,mod\,p)$ ó $b=1$ $(x\equiv g^t g^{u-t} \equiv sg^y \,mod\,p)$ respectivamente, es la misma, $1/2$.
	Tenemos entonces que los ensambles $\{f(0,\Upsilon)\}$ y $\{f(1,\Upsilon)\}$ son idénticos y el esquema es de \textbf{secreto incondicional}.
	
\end{proof}


\hfil

Finalmente utilizamos el problema del isomorfismo de grafos para mostrar otro esquema de secreto incondicional. En este caso P y V escogen un grafo $G=(V,E)$ ($n=\mid V \mid $). V escoge al azar una permutación $\pi \in_R Sym(V)$ del grafo y calcula $H=\pi(G)$. El par de grafos $(G,H)$ lo conocerán tanto P como V, pero la permutación $\pi$ la mantendrá en secreto V. Los conjuntos del esquema de compromiso son $\Upsilon = Sym(V)$ y $\chi = \{ H \mid H=\pi(G),\, \pi\in_R Sym(V) \}$.


\hfil

\rule{\textwidth}{1pt}
\begin{algorithm}[Compromiso de bit basado en isomorfismo de grafos]
	\hfil
	
	\textit{Ocultación}: P elige al azar $\gamma \in \Upsilon$ y oculta el bit $b$ como:
	\[X = f(b,\gamma) = 
	\begin{cases}
	\gamma(G) & si\ b=0 \\
	\gamma(H) & si\ b=1 \\
	\end{cases}
	\]
	
	\textit{Apertura}: P envía a V el valor $\gamma$. V calcula el bit $b$:
	\[ b = v(X,\gamma) = 
	\begin{cases}
	0  & si\ \gamma(G)=X \\
	1 & si\ \gamma(H)=X \\
	\bullet & en\ otro\ caso.
	\end{cases}
	\]
	\label{bitcommitGI:alg}
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil

\begin{proposition}
	El algoritmo \ref{bitcommitGI:alg} es un esquema de compromiso de bit con vinculación computacional y secreto incondicional.
\end{proposition}

\begin{proof}
	P podría atacar el esquema si conociera el isomorfismo de $G$ a $H$, componiéndolo con $\gamma$ para cambiar el bit que V abriría. Como suponemos que P es una máquina limitada computacionalmente, no puede resolver el problema del isomorfismo de grafos y por tanto el esquema de compromiso es de \textbf{vinculación computacional}.
	
	Además, como los posibles $\gamma$ para abrir un bit son permutaciones aleatorias de $G$, compuestas o no con $\pi$, la probabilidad de que dado un $X$ el bit $b$ sea $0$ ó $1$ es $1/2$ en ambos casos, de modo que los ensambles $\{f(0,\Upsilon)\}$ y $\{f(1,\Upsilon)\}$ son idénticos, y tenemos \textbf{secreto incondicional}.
\end{proof}

\subsection{Esquemas de compromiso con vinculación incondicional}

Podemos conseguir esquemas de compromiso con vinculación incondicional a costa de obtener secreto computacional, como demostramos antes, no podemos obtener ambas propiedades a la vez de modo incondicional. Veremos en este apartado un ejemplo basado en residuos cuadráticos.

\hfil

Partiendo del problema del residuo cuadrático, para $N=pq$, los conjuntos $\mathbb{Z}_N^{Q+}$ y $\mathbb{Z}_N^{Q-}$ son polinomialmente indistinguibles. En este caso, P inicia el esquema 
eligiendo 2 primos aleatorios suficientemente grandes, $p$ y $q$, y un \textbf{no}-residuo cuadrático $s\in \mathbb{Z}_N^{Q-}$, es decir, con símbolo de Jacobi $1$. El par $(s,N)$ se hace público para V. El conjunto de \textit{claves} del esquema es $\Upsilon = \mathbb{Z}_N^*$, y el de posibles valores de los blobs es $\chi = \mathbb{Z}_N^Q$, los valores con símbolo de Jacobi $1$, sea o no residuo cuadrático.



\hfil

\rule{\textwidth}{1pt}
\begin{algorithm}[Compromiso de bit basado en residuos cuadráticos]\label{commitQRbind:alg}
	\hfil
	
	\textit{Ocultación}: P elige al azar $y\in \mathbb{Z}_N^*$ y oculta el bit $b$ como:
	\[x = f(b,y) = s^b y^2 \, mod \, N \]
	
	\textit{Apertura}: P envía a V el valor $y$. V calcula el bit $b$:
	\[ b = v(x,y) = 
	\begin{cases}
	0  & si\ x\equiv y^2 \, mod \, N  \\
	1 & si\ x\equiv s\cdot y^2 \, mod \, N \\
	\bullet & en\ otro\ caso.
	\end{cases}
	\]
	\label{bitcommitQR2:alg}
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil


\begin{proposition}
	El algoritmo \ref{bitcommitQR2:alg} es un esquema de compromiso de bit con secreto computacional y vinculación incondicional.
\end{proposition}

\begin{proof}
	El valor del testigo $x$ será un residuo cuadrático si $b=0$, o un no-residuo cuadrático si $b=1$, y como $ \mathbb{Z}_N^{Q+} \cap \mathbb{Z}_N^{Q-} = \emptyset $, P es incapaz de abrir el testigo con otro valor de $b$, aunque sea computacionalmente ilimitado. Tenemos por tanto \textbf{vinculación incondicional}.
	
	Sin embargo, los ensambles $\{f(0,\Upsilon)\}$ y $\{f(1,\Upsilon)\}$ son sólo polinomialmente indistinguibles, bajo la suposición de que el problema QR es \textit{difícil}, de modo que obtenemos sólo \textbf{secreto computacional}.
\end{proof}


Este esquema es casi idéntico al \ref{bitcommitQR:alg}, pero la diferencia radica en que en el esquema con secreto incondicional, sólo usamos residuos cuadráticos, de modo que no se podía distinguir una apertura de otra hasta que la enviara P, y en este caso utilizamos un no-residuo cuadrático con símbolo de Jacobi $1$, y en vez de secreto incondicional, conseguimos vinculación incondicional.

%TODO: aquí el concepto de cifrado estadístico

\hfil

\subsection{Esquemas de compromiso para cadenas de bits}

Existen pruebas interactivas donde P necesita comprometerse con un valor en un conjunto mayor que $\{0,1\}$, de modo que para ocultarlo, con las técnicas previas, debería representar en base binaria dicho valor y ejecutar el esquema de compromiso bit a bit, lo cual es claramente ineficiente. Vamos a ampliar la definición \ref{commit:def}:

\begin{definition}\label{commit:def2}
	Un esquema de compromiso de un cadenas de $n$ bits es un par de funciones $(f,v)$ de tiempo polinomial. La función
	
	$
	f:\{0,1\}^n\, x\, \Upsilon \to \chi
	$
	\\transforma la cadena $s=(b_1,\dots,b_n)\in \{0,1\}^n$ con una clave aleatoria $y\in \Upsilon$. El valor $x=f(b,y)$ lo llamaremos \textit{blob} o \textit{testigo} de $s$. La función de verificación
	
	$
	v:\chi \, x \, \Upsilon \to \{0,1,\dots,2^{n-1}\bullet\}
	$
	\\abre el blob revelando la cadena $s$, o indicando que no es un par (blob,clave) válido.
	
\end{definition}

\hfil

Veamos dos ejemplos basados en el problema del logaritmo discreto. El primero se basa en el compromiso de Pedersen, siendo de secreto incondicional, mientras que en el segundo ejemplo, basado en el algoritmo de ElGamal\index{ElGamal}, conseguimos vinculación incondicional.


\hfil

Comencemos por el compromiso de Pedersen. Como antes, P y V deben elegir un primo $p$ suficientemente grande para que el problema del logaritmo discreto sea impracticable. Además, eligen un generador $g\in \mathbb{Z}_p^*$ y un valor aleatorio $h$ tal que no se conoce $log_g h$. El conjunto de \textit{claves} será $\Upsilon = \mathbb{Z}_{p-1}$ y el de blobs $\chi = \mathbb{Z}_p^*$. El compromiso de una cadena $s$ se obtiene como sigue:


\hfil

\rule{\textwidth}{1pt}
\begin{algorithm}
	\hfil
	
	\textit{Ocultación}: P elige al azar $y\in \Upsilon$ y oculta $s$ como:
	\[x = f(s,y) = g^s h^y \, mod \, p \]
	
	\textit{Apertura}: P envía a V el par $(s',y')$. V comprueba que
	\[ s = v(x,y) = 
	\begin{cases}
	s' & si\ x\equiv g^{s'} h^{y'} \, mod \, p  \\
	\bullet & en\ otro\ caso.
	\end{cases}
	\]
	\label{bitscommitDL:alg}
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil



\begin{proposition}
	El algoritmo \ref{bitscommitDL:alg} es un esquema de compromiso de cadena de bits con vinculación computacional y secreto incondicional.
\end{proposition}

\begin{proof}
	Para poder romper la propiedad de vinculación, haría falta encontrar los pares $(s_0,y_0)$ y $(s_1,y_1)$, con $s_0\neq s_1$, tal que
	\[
	g^{s_0}h^{y_0} \equiv g^{s_1}h^{y_1}\, mod \, p
	\]
	operando obtenemos $g^{s_0-s_1}\equiv h^{y_1-y_0}\, mod \, p$, y podemos despejar 
	\[
	h \equiv g^{ (s_0-s_1) (y_1-y_0)^{-1} \, mod\, p-1 } \, mod \, p
	\]
	y habríamos calculado el logaritmo discreto de $h$ en base $g$, pero para un P computacionalmente limitado, y suponiendo que el problema del logaritmo discreto es impracticable, esto no es posible, por lo que obtenemos \textbf{vinculación computacional}.
	
	Por otra parte, para cualquier par $(s,y)$ y $t$ tal que $h\equiv g^t\, mod \, p$, para cualquier posible valor $s'$ tenemos que $y'=\frac{s-s'}{t} + y$ cumple $g^s h^y \equiv g^{s'} h^{y'}\, mod \, p$. Es decir, $s'$ se puede abrir con la \textit{clave} $y' = \frac{s-s'}{t} + y$, donde $y$ se elige uniformemente en $\mathbb{Z}_p^*$. Tenemos entonces que el esquema es de \textbf{secreto incondicional}.
	
\end{proof}


\hfil

Ahora veamos el segundo ejemplo de compromiso de cadenas de bits. La inicialización es la misma que en el caso anterior, P y V conocen un primo $p$, un generador $g\in \mathbb{Z}_p^*$ y un valor aleatorio $h\in \mathbb{Z}_p^*$ tal que no se conoce $log_b h$. Los conjuntos del esquema de compromiso son $\Upsilon = \mathbb{Z}_{p-1}$ y $\chi = \mathbb{Z}_p^*$.

\hfil

\rule{\textwidth}{1pt}
\begin{algorithm}
	\hfil
	
	\textit{Ocultación}: P elige al azar $y\in \Upsilon$ y oculta $s$ como el par de valores:
	\[(x_1,x_2) = f(s,y) = ( g^y \, mod \, p ,\, g^sh^y \, mod \, p) \]
	
	\textit{Apertura}: P envía a V el par $(s',y')$. V comprueba que
	\[ s = v(x,y) = 
	\begin{cases}
	s' & si\ x_1\equiv g^{y'} \, mod \, p  \quad y \quad x_2\equiv  g^{s'}h^{y'} \, mod \, p \\
	\bullet & en\ otro\ caso.
	\end{cases}
	\]
	\label{bitscommitDL2:alg}
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil


\begin{proposition}
	El algoritmo \ref{bitscommitDL:alg} es un esquema de compromiso de cadena de bits con vinculación computacional y secreto incondicional.
\end{proposition}

\begin{proof}
	En este caso, el valor de $x_1 = g^y \, mod \, p$ determina unívocamente el valor de $y$ elegido por P, y de este modo se fija el posible valor de $s$ en $g^s h^y\, mod\, p$. Obtenemos así \textbf{vinculación incondicional}.
	
	A cambio, como ahora el posible valor de $y$ es único, un V con suficiente capacidad computacional podría resolver el logaritmo discreto de $x_1$, obtener $y$, y entonces despejar $s$ de $x_2$, antes de que P realice la apertura. Sin embargo, ante un V limitado, y suponiendo que el problema del logaritmo discreto es \textit{difícil}, obtenemos \textbf{secreto computacional}.
\end{proof}

Una ventaja de este esquema frente al anterior, es que P puede elegir el valor de $h$ por su cuenta, sin que V desconfíe de si conoce o no su logaritmo discreto. En el caso anterior, si P calcula maliciosamente $h$ como $h=g^t\,mod\,p$, hemos visto que puede abrir un blob con el valor que quiera. En este esquema, gracias a la vinculación incondicional, aunque P conozca $t$, no puede romper el esquema de compromiso. 	

\hfil

Para finalizar este capítulo, veamos las implicaciones de estos dos tipos de esquemas de compromiso existentes, los de secreto o vinculación incondicional, sobre las pruebas de conocimiento cero.

Cuando tratamos con un esquema de compromiso de vinculación incondicional, podemos trabajar incluso con un P de capacidad computacional ilimitada, como en las pruebas de conocimiento cero perfectas, y V estará seguro de que no se le engaña al abrir el testigo presentado. Sin embargo, desde la perspectiva de P, los blobs que no se abren, y deben ocultar la información, pueden verse comprometidos en el futuro si los problemas en los que se basa la propiedad de secreto computacional consiguen resolverse, bien para el caso general, o bien para las instancias de una cierta interacción pasada.

Por otro lado, si utilizamos esquemas de compromiso con secreto incondicional, P puede estar seguro de que los valores no revelados se mantendrán seguros en el futuro. Sin embargo, cuando un V se enfrenta a un P \textit{todopoderoso}, la confianza en que P no cambiará el valor comprometido desaparece. Por eso, este tipo de compromisos sólo se pueden utilizar cuando en la prueba interactiva estudiada P no precisa de ser computacionalmente ilimitado.






\section{Pruebas de conocimiento cero computacionales}


Introducimos ahora la última variedad de pruebas de conocimiento cero que veremos en este capítulo. La definición parte de la de conocimiento cero perfecta, pero considerando que los ensambles de la Vista y Simulador son indistinguibles sólo de manera computacional, sin necesidad de ser idénticos.


\begin{definition}[Propiedad de conocimiento cero computacional]\index{Conocimiento Cero Computacional}
	\hfil
	
	Un sistema de prueba interactiva (completo y robusto), para un problema de decisión $Q$, es \textit{de conocimiento cero computacional} si el ensamble $Vista_{P,V^*}(q,h)$ es indistinguible polinomialmente al ensamble generado por un Simulador $S_{V^*}(q,h)$, para cualquier instancia $Verdadera$ $q\in Q$ y cualquier historial $h$.
\end{definition}

\hfil


Para las pruebas que veremos en esta sección utilizaremos esquemas de compromiso con vinculación incondicional y secreto computacional, pues ante un P \textit{todopoderoso}, debemos asegurarnos que no puede cambiar su compromiso. El esquema utilizado en cada algoritmo es arbitrario mientras cumpla la propiedad, de modo que denotaremos a un blob como una \textit{caja negra}\index{Caja negra} $C$ que oculta un cierto valor, y lo desvela entregando su \textit{llave}\index{Llave} a V.


En esta clase de pruebas de conocimiento cero se encuentran problemas como el del camino hamiltoniano (HC), o el de la 3-coloración del grafo (G3C).


\subsection{Prueba de conocimiento cero para un grafo hamiltoniano}

Dado el problema de decisión del grafo hamiltoniano (\autoref{problemaHC}), mostramos el algoritmo descrito por \citeauthor{blum} en \citep{blum}:


\rule{\textwidth}{1pt}
\begin{algorithm}[Prueba interactiva para HC]\label{HCinteractive:alg}
	
	\hfil
	
	\textit{Datos comunes}: Una instancia $G=(V,E)$ del Problema HC. $\mid V \mid = n$ es el tamaño del problema.
	
	\textit{Protocolo}: 
	
	P encuentra un ciclo hamiltoniano de $G$. Usará el mismo ciclo durante el resto de la prueba.
	
	Sea $t(n)$ un polinomio en $n$. P y V repiten $t(n)$ veces los siguientes pasos.
	
	\begin{enumerate}
		
		\item P oculta $G$ en cajas negras: asocia, de manera uniformemente aleatoria, los vértices $v_1, v_2, \dots v_n$ a las cajas $C_1, C_2, \dots C_n$ (una permutación sobre los vértices del grafo); además, para cada par de cajas $(C_i,C_j)$ prepara otra caja llamada $C_{ij}$ que guardará un $1$ si los vértices ocultos en $C_i$ y $C_j$ son adyacentes, ó $0$ en caso contrario.
		
		\item P $\rightarrow$ V :\quad $n + \binom{n}{2}$ cajas negras: $C_1, C_2, \dots C_n, C_{1,2},\dots, C_{n-1,n}$
		
		\item V $\rightarrow$ P :\quad $b \in_R \{0,\,1\}$.
		
		\item Si $b=0$, P envía las llaves para abrir todas las cajas.
		
		Si $b=1$, P abre exactamente $n$ cajas, $C_{ij}, C_{jk}, C_{kl}, \dots C_{l^`i}$, que corresponden al ciclo hamiltoniano escondido por los vértices escondidos en las cajas $C_1, C_2, \dots C_n$.
		
		\item Si $b=0$, V comprueba que el grafo descubierto por las cajas sea G.
		
		Si $b=1$, V comprueba que los índices de las cajas  $C_{ij}, C_{jk}, \dots C_{l^`i}$ forman un ciclo y que todas contienen un $1$.
		
		Si la comprobación falla, V termina en rechazo. En caso contrario, vuelve al paso 1.
		
		
	\end{enumerate}
	
	Tras $t(n)$ rondas, V termina y acepta la instancia como $Verdadera$, $G$ es hamiltoniano.
	
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil

\begin{theorem}
	El protocolo \ref{HCinteractive:alg} es una prueba interactiva.
\end{theorem}

\begin{proof}
	El protocolo se ejecuta en $t(n)$ iteraciones, de modo que es probabilístico en tiempo polinomial. Ahora debemos comprobar la completitud y robustez.
	
	El protocolo es \textit{completo}, pues si el grafo es en verdad hamiltoniano, una instancia $Verdadera$, P todopoderoso computacionalmente podrá encontrar un ciclo, y siguiendo el algoritmo, siempre podrá descubrir ante V el grafo $G$ o el ciclo elegido, según el bit del reto.
	
	Si un P$^*$ tramposo no conoce un ciclo hamiltoniano de $G$, puede intentar adivinar cuándo V pedirá descubrir el grafo o el ciclo. En el primer caso, seguirá el protocolo, ocultando $G$ en las cajas negras. En el segundo caso, P$^*$ sólo debe elegir un ciclo de cajas  $C_{ij}, C_{jk}, \dots C_{l^`i}$ donde introducirá el valor $1$, haya o no una arista uniendo los vértices en $G$. Si V pide descubrir el ciclo, P$^*$ revelará un ciclo hamiltoniano, pero no del grafo $G$.
	
	Si P$^*$ no acierta correctamente qué bit enviará V, en cada ronda hay una probabilidad de $1/2$ de que V pille a P$^*$ en su mentira. Ejecutando el protocolo $t(n)$ veces, la probabilidad de que un P$^*$ tramposo engañe a V es de $2^{-t(n)}$, por tanto, la prueba es \textit{robusta}.
\end{proof}




\begin{theorem}
	La prueba interactiva \ref{HCinteractive:alg} es de conocimiento cero computacional.
\end{theorem}

\begin{proof}
	Debemos construir un simulador para el protocolo anterior. Como en las pruebas anteriores, suponemos que V$^*$ utiliza una función probabilística en tiempo polinomial $F$ que con la información disponible elige el bit $b$ del reto de manera no uniforme.
	
	\hfil 
	
	\rule{\textwidth}{1pt}
	
	\textbf{Simulador para el problema HC} $S_{V^*}(G=(V,E), h)$.
	
	\hfil
	
	\textit{Datos}: \quad $G$, una instancia $Verdadera$ del problema HC; $h$, transcripciones de ejecuciones previas del protocolo; $v_i$, transcripción de la interacción actual ($i$ rondas).
	
	\textit{Ejecución}: Repetir para $i+1 \leq t(n)$:
	
	\begin{enumerate}
		\item Elegir $b_{i+1} \in_R \{0,\,1\}$
		
		\item \textbf{Si} $b_{i+1} = 0$, \textbf{entonces} oculta $G$ en una permutación aleatoria de cajas negras. \\
		\textbf{Si no}, oculta un n-ciclo cualquiera en cajas negras.\\
		En ambos casos produce las cajas negras $C_1^{i+1}, \dots, C_{n-1,n}^{i+1}$.\\
		
		\item \textbf{Si} $b_{i+1} = F(G,h,v_i,C_1^{i+1}, \dots, C_{n-1,n}^{i+1})$, \textbf{entonces} añadir la tupla \\ $(C_1^{i+1}, \dots, C_{n-1,n}^{i+1},b_{i+1},K_{i+1})$ a la transcripción, donde $K_{i+1}$ es el conjunto de claves para abrir las cajas, según el valor $b_{i+1}$. \\
		\textbf{Si no}, volver al paso 1.
		
		\item $i = i+1$
		
	\end{enumerate}
	
	\rule{\textwidth}{1pt}
	
	\hfill
	
	Al haber una probabilidad de $1/2$ de que el bit $b_{i+1}$ coincida con el valor de la función $F$, el simulador es probabilístico, con un tiempo estimado de ejecución de 2 iteraciones por cada una de las $t(n)$ rondas, de modo que es de tiempo polinomial.
	
	Tenemos los ensambles probabilísticos 
	\[Vista_{P,V^*}(G,h) = (G,h,E_1,B_1,K_1,\dots , E_{t(n)}, B_{t(n)}, K_{t(n)}),\ y \]
	\[S_{V^*}(G,h) = (G,h,E_1',B_1',K_1',\dots , E_{t(n)}', B_{t(n)}', K_{t(n)}').\]
	donde $E_i$ y $E_i'$ son las variables aleatorias que representan las cajas negras del compromiso, $B_i$ y $B_i'$ las v.a. de los bits elegidos por V en el reto, y $K_i$ y $K_i'$ las v.a. de las llaves reveladas.
	
	Por inducción sobre $i$, cuando $i=0$, los ensambles corresponden a la misma tupla $(G,h)$, de modo que son idénticos.
	
	Continuamos la inducción suponiendo que para $i-1$ los ensambles son indistinguibles computacionalmente. 
	
	Analizando la prueba interactiva \ref{HCinteractive:alg}, en la interacción $i$, cuando V elige $b_{i}=0$, éste obtiene de P una de las $n!$ posibles permutaciones del grafo $G$, y si V eligiera $b_i=1$, obtendría un $n$-ciclo aleatorio, de los $n!$ posibles también, pues P forma dicho $n$-ciclo de cajas negras a partir de un ciclo hamiltoniano prefijado y la permutación aleatoria aplicada a $G$. La probabilidad de descubrir todo $G$ o un $n$-ciclo depende de la elección de $b_i$, cuya probabilidad viene determinada por $F$.
	
	Del mismo modo, analizando el simulador,  $F$ determinará la probabilidad de que en la transcripción aparezca un $0$ o un $1$ en el bit $b_i$. Según el valor de $b_i$, el simulador escogerá una de las $n!$ permutaciones posibles de $G$ para ocultar el grafo en cajas negras, o bien uno de los $n!$ posibles $n$-ciclos, forme o no un ciclo hamiltoniano en $G$.
	
	Ahora bien, suponíamos que las cajas negras eran en realidad la aplicación de un esquema de compromiso con vinculación incondicional, para proteger a V frente a un P \textit{todopoderoso} que pudiese cambiar los valores comprometidos. Vimos en la sección anterior que al tener vinculación incondicional, sólo podemos aspirar a secreto computacional, en nuestro modelo de comunicación donde P y V ven todo lo que se les envía. Esto significa que la única manera de diferenciar los ensambles anteriores es rompiendo el secreto del esquema de compromiso, y suponemos que no existe ningún algoritmo probabilístico polinomial que pueda hacerlo.
	
	Tenemos entonces, que los ensambles son computacionalmente indistinguibles, y la prueba interactiva es de conocimiento cero computacional.
\end{proof}




\subsection{Prueba de conocimiento cero para la 3-coloración de un grafo}

Otra prueba interactiva de conocimiento cero computacional es la de demostrar que un grafo $G$ posee una 3-coloración de sus nodos (\autoref{problemaG3C}).

Como los problemas G3C y HC, de las sección anterior, son \textbf{NP}-completos, y como todos los problemas \textbf{NPC} son computacionalmente equivalentes, en el sentido de que todos se pueden reducir polinomialmente a otro problema \textbf{NPC}, tenemos que todo problema en \textbf{NPC} tiene una prueba de conocimiento cero computacional.


Blum presenta en \citep{blum} una prueba de conocimiento cero para G3C, que sigue las líneas de la prueba del ciclo hamiltoniano, utilizando un bit como reto para desvelar el grafo $G$ o una prueba de que se ocultó una 3-coloración. Sin embargo, en \citep{pieprzyk2013fundamentals} se muestra una variación de la prueba que creemos es más sencilla de entender.

La idea de esta prueba es que en cada iteración, P elige una permutación aleatoria de la 3-coloración, $\pi \in Sym(\{1,2,3\})$, y oculta cada vértice coloreado en una caja negra. El \textit{testigo} que enviará a V consistirá en ocultar toda la 3-coloración del grafo en $n$ cajas negras cuyos índices corresponden a los vértices del grafo. V elegirá como \textit{reto} una arista aleatoria. Como \textit{respuesta}, P enviará la coloración permutada de esa arista, que deberá tener colores distintos en cada extremo, y las claves de cifrado de cada una, de modo que V podrá comprobar si corresponden al \textit{testigo} enviado:

\hfil

\rule{\textwidth}{1pt}
\begin{algorithm}[Prueba interactiva para G3C]
	
	\hfil
	
	\textit{Datos comunes}: Una instancia $G=(V,E)$ del Problema G3C.  $\mid E \mid=m$ y $\mid V \mid = n$ es el tamaño del problema.
	
	\textit{Protocolo}: 
	
	P encuentra una 3-coloración $\phi$ de $G$.
	
	Sea $t(n)$ un polinomio en $n$. P y V repiten $t(n)\mid E \mid$ veces los siguientes pasos.
	
	\begin{enumerate}
		
		\item P selecciona al azar una permutación $\pi \in_R Sym(\{1,2,3\})$. Oculta en $n$ cajas negras la coloración: la caja $C_j$ ocultará el valor $\pi(\phi(v_j))$ del color permutado del vértice $v_j$.
		
		\item P $\rightarrow$ V :\quad $n$ cajas negras: $C_1, C_2, \dots C_n$.
		
		\item V $\rightarrow$ P :\quad $(u,v) \in_R E$, una arista aleatoria de $G$.
		
		\item P $\rightarrow$ V :\quad las claves $k_u$, $k_v$ que abren las cajas $C_u$, $C_v$.
		
		\item V abre las cajas y comprueba que $\pi(\phi(u)) \neq \pi(\phi(v))$.
		
		Si la comprobación falla, V termina en rechazo. En caso contrario, vuelve al paso 1.
		
		
	\end{enumerate}
	
	Tras $t(n)$ rondas, V termina y acepta la instancia como $Verdadera$, $G$ posee una 3-coloración.
	\label{G3Cinteractive:alg}
\end{algorithm}
\rule{\textwidth}{1pt}

\hfil



\begin{theorem}
	El protocolo \ref{G3Cinteractive:alg} es una prueba interactiva.
\end{theorem}

\begin{proof}
	La completitud es inmediata, pues si existe 3-coloración, un P ilimatado computacionalmente la podrá calcular, y podrá dar para cada $(u,v)\in E$ colores distintos en cada ronda.
	
	Si P$^*$ no conoce la 3-coloración, al menos hay una arista a la que P no puede dar colores distintos a sus vértices, y hay una probabilidad de $\frac{1}{\mid E \mid}$ de que V le rechace, es decir, una probabilidad $1-\frac{1}{\mid E \mid}$ de que P$^*$ triunfe. Tras $t(n)\mid E \mid$ rondas, P$^*$ sólo engañaría a V con una probabilidad $(1-\frac{1}{\mid E \mid})^{t(n)\mid E \mid} \approx e^{-t(n)}$, por lo que la prueba es robusta.
	
\end{proof}


\hfil

\begin{theorem}
	La prueba interactiva \ref{G3Cinteractive:alg} es de conocimiento cero computacional.
\end{theorem}

\begin{proof}
	La propiedad de conocimiento cero se prueba con un simulador que funciona como los anteriores, primero se elige el \textit{reto} (arista) y la \textit{respuesta} (dos colores), se calcula el \textit{testigo} respecto de ambos y se comprueba si V hubiera elegido dicho \textit{reto} a partir de un algoritmo probabilístico polinomial $F$:
	
	
	\hfil 
	
	\rule{\textwidth}{1pt}
	
	\textbf{Simulador para el problema G3C} $S_{V^*}(G=(V,E), h)$.
	
	\hfil
	
	\textit{Datos}: \quad $G$, una instancia $Verdadera$ del problema G3C; $h$, transcripciones de ejecuciones previas del protocolo; $v_{i-1}$, transcripción de la interacción actual ($i-1$ rondas).
	
	\textit{Ejecución}: Repetir para $i+1 \leq t(n)$:
	
	\begin{enumerate}
		\item Elegir $e=(u,v)\in_R E$ una arista, y sus colores $(a,b)\in_R \{ (\alpha,\beta) \mid \alpha \neq \beta ;\ \alpha,\beta \in \{1,2,3\}  \}$ de manera aleatoria.
		
		\item Generar las cajas negras $C_j$ para $j=1,\dots n$ del siguiente modo:
		\[
		C_j \, oculta \, \begin{cases}
		a & si\ v_j=u,\\
		b & si\ v_j=v,\\
		0 & en\ otro\ caso.\\
		\end{cases}
		\] donde $v_j$ es un vértice de $G$.
		
		
		\item \textbf{Si} $e = F(G,h,v_{i-1},C_1, \dots, C_{n})$, \textbf{entonces} añadir la tupla \\ 
		$(C_1, \dots, C_{n},e=(u,v),k_u,k_v)$ a la transcripción, donde $K_{i+1}$ es el conjunto de claves para abrir las cajas, según el valor $b_{i+1}$. \\
		\textbf{Si no}, volver al paso 1.
		
		\item $i = i+1$
		
	\end{enumerate}
	
	\rule{\textwidth}{1pt}
	
	\hfill
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	Durante una ronda del simulador tenemos una probabilidad de $\frac{1}{\mid E \mid}$ de que la arista escogida en el primer paso coincida con la que el algoritmo $F$ elegiría, con $t(n)$ rondas a generar. Tenemos un algoritmo probabilístico con tiempo esperado de ejecución polinomial.
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	
	Veamos ahora los ensambles de la Vista y la Simulación.
	\[Vista_{P,V^*}(G,h) = (G,h,C_1,E_1,K_1,\dots , C_{t(n)}, E_{t(n)}, K_{t(n)}),\ y \]
	\[S_{V^*}(G,h) = (G,h,C_1',E_1',K_1',\dots , C_{t(n)}', E_{t(n)}', K_{t(n)}').\]
	
	Donde la v.a. $C_i$ representa el conjunto de $n$ cajas negras que oculta la permutación de la coloración, la v.a. $E_i$ representa la arista $(u,v)$ elegida como reto por V en la ronda $i$, y la v.a. $K_i$ representa el par de llaves $(k_u,k_v)$ enviado como respuesta.
	
	Por inducción sobre $i$, cuando $i=0$, los ensambles de la Vista y Simulador son idénticos, $(G,h)$. Suponemos cierto para $i-1$, en la $i$-ésima iteración tendremos:
	
	
	En la Vista y el Simulador, las variables aleatorias $C_i$ y $C_i'$ corresponden a $n$ cajas negras, que cumplen un esquema de compromiso con vinculación incondicional y secreto computacional, de modo que a partir de estas $n$ cajas negras suponemos que no existe ningún algoritmo probabilístico en tiempo polinomial que las distinga de cualquier otra caja negra. Por tanto, la probabilidad de que aparezcan unas cajas negras u otras en la Vista y Simulador es computacionalmente indistinguible e independiente de las otras variables.
	
	Respecto a las v.a. $E_i$ y $E_i'$, ambas dependen de la probabilidad de elegir un nodo de $F$, que podemos supones es $p_F$, idéntica para ambas.
	
	En la apertura de las cajas negras con las claves de $K_i$ y $K_i'$ se desvelan dos colores distintos aleatorios, en la Vista porque la 3-coloración implica que ambos son distintos y después se le aplica una permutación aleatoria de entre las $3!$ posibles, por lo que dos colores distintos tienen una probabilidad uniforme de ser revelados, y por tanto, la misma probabilidad que la elección de colores aleatoria del Simulador.
	
	Tal como ocurría en la prueba del grafo hamiltoniano, la condición de conocimiento cero computacional proviene de utilizar un esquema de compromiso con vinculación incondicional, y secreto computacional.
\end{proof}




